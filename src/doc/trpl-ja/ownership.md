% 所有権

このガイドはRustの所有権システムの3つの発表の1つです。
これはRustの最も独特で注目されている機能です。そして、Rust開発者はそれについて高度に精通しておくべきです。
所有権はどのようにRustがその最大の目標、メモリー安全性を得るのかということです。
そこにはいくつかの別個の概念があり、各概念が独自の章を持ちます。

* あなたが今読んでいる、所有権
* [ボローイング][borrowing]、そしてそれらに関連する機能、「参照」
* ボローイングのもう一歩進んだ概念、[生存期間][lifetimes]

それらの3つの章は関連していて、それらには順序があります。
あなたは所有権システムを完全に理解するために、3つ全てを必要とするでしょう。

[borrowing]: references-and-borrowing.html
[lifetimes]: lifetimes.html

# メタ

私たちが詳細に入る前に、所有権システムについての2つの重要な注意があります。

Rustは安全性とスピートに焦点を合わせます。
Rustはそれらの目標をたくさんの「0コストの抽象化」を通じて成し遂げます。それは、Rustでは抽象化を機能させるためのコストをできる限り小さくすることを意味します。
所有権システムは0コストの抽象化の主な例です。
私たちがこのガイドの中で話すであろう解析の全ては _コンパイル時に行われます_ 。
あなたはそれらのどの機能に対しても実行時のコストを全く支払いません。

しかし、このシステムはあるコストを持ちます。それは学習曲線です。
多くの新しいRustのユーザーは私たちが「ボローチェッカーとの戦い」と好んで呼ぶものを経験します。そこではRustコンパイラーが開発者が正しいと考えるプログラムをコンパイルすることを拒絶します。
所有権がどのように機能するのかについてのプログラマーのメンタルモデルがRustの実装する実際のルールにマッチしないため、これはしばしば起きます。
しかし、よいニュースがあります。より経験豊富なRustの開発者は次のことを報告します。一度彼らが所有権システムのルールとともにしばらく仕事をすれば、彼らがボローチェッカーと戦うことは少なくなっていくということです。

それを念頭に置いて、所有権について学びましょう。

# 所有権

Rustでは[変数束縛][bindings]は所有物を持ちます。つまり、それらはそれらが束縛されているものの「所有権を持つ」ということです。
これは束縛がスコープから外れるとき、Rustは束縛されているリソースを解放するだろうということを意味します。
例えばこうです。

```rust
fn foo() {
    let v = vec![1, 2, 3];
}
```

`v`がスコープに入るとき、新しい[`Vec<T>`][vect]が作られます。
この場合、ベクターも3つの要素のために[ヒープ][heap]に空間を割り当てます。
`foo()`の最後で`v`がスコープから外れるとき、Rustはベクターに関連するもの全てを取り除くでしょう。それがヒープ割当てのメモリーであってもです。
これはスコープの最後で確定的に起こります。

[vect]: ../std/vec/struct.Vec.html
[heap]: the-stack-and-the-heap.html
[bindings]: variable-bindings.html

# ムーブセマンティクス

しかし、ここではもっと微妙なことがあります。それは、Rustは与えられたリソースに対する束縛が _1つだけ_ あるということを保証するということです。
例えば、もし私たちがベクターを持つのであれば、私たちはそれを別の束縛に割り当てることができます。

```rust
let v = vec![1, 2, 3];

let v2 = v;
```

しかし、もし私たちが後で`v`を使おうとすると、エラーが出ます。

```rust,ignore
let v = vec![1, 2, 3];

let v2 = v;

println!("v[0] is: {}", v[0]);
```

それはこのように見えます。

```text
error: use of moved value: `v`
println!("v[0] is: {}", v[0]);
                        ^
```

もし私たちが所有権を受け取る関数を定義して、引数として何かを渡した後でそれを使おうとするならば、同じようなことが起きます。

```rust,ignore
fn take(v: Vec<i32>) {
    // what happens here isn’t important.
}

let v = vec![1, 2, 3];

take(v);

println!("v[0] is: {}", v[0]);
```

「use of moved value」という同じエラーです。
私たちが所有権を何か別のものに転送するとき、私たちは私たちの参照するものを「移転する」と言います。
あなたはここでは特別な種類の注釈を必要としません。
それはRustの行うデフォルトの動作です。

## 詳細

私たちが束縛を移転した後でそれを使うことができない理由は微妙ですが重要です。
私たちはこのようなコードを書いたとします。

```rust
let v = vec![1, 2, 3];

let v2 = v;
```

最初の行はベクターオブジェクト`v`とそれの含むデータのためのメモリーを割り当てます。
ベクターオブジェクトは[スタック][sh]に保存され、[ヒープ][sh]に保存された内容（`[1, 2, 3]`）へのポインターを含みます。
私たちが`v`を`v2`に移転するとき、それは`v2`のためにそのポインターのコピーを作ります。
それは、ヒープ上のベクターの内容へのポインターが2つあることを意味します。
それはデータ競合を持ち込むことでRustの安全性保証に違反するでしょう。
そのため、Rustは私たちが移転を終えた後の`v`の使用を禁止します。

[sh]: the-stack-and-the-heap.html

最適化が状況によってはスタック上のバイトの実際のコピーを削除するかもしれないことに気付くことも重要です。
そのため、それは最初に思ったほど非効率ではないかもしれません。

## `Copy`型

私たちは所有権が他の束縛に転送されるとき、あなたは元の束縛を使うことができないということを証明しました。
しかし、この挙動を変更する[トレイト][traits]があります。それは`Copy`と呼ばれます。
私たちはトレイトをまだ議論していませんが、とりあえずあなたはそれらを挙動を追加するある型への注釈として考えることができます。
例えばこうです。

```rust
let v = 1;

let v2 = v;

println!("v is: {}", v);
```

この場合、`v`は`i32`で、それは`Copy`トレイトを実装します。
これはちょうど移転と同じように、私たちが`v`を`v2`に割り当てるとき、データのコピーが作られるということを意味します。
しかし、移転と違って私たちは後でまだ`v`を使うことができます。
これは`i32`がどこか別の場所へのポインターを持たず、コピーが完全コピーだからです。

全てのプリミティブ型は`Copy`トレイトを実装し、そのため、推測どおりそれらの所有権は「所有権ルール」に従っては移転しません。
例を与えるために、2つのコードスニペットを単にコンパイルしましょう。なぜなら、`i32`型と`bool`型は`Copy`トレイトを実装するからです。

```rust
fn main() {
    let a = 5;

    let _y = double(a);
    println!("{}", a);
}

fn double(x: i32) -> i32 {
    x * 2
}
```

```rust
fn main() {
    let a = true;

    let _y = change_truth(a);
    println!("{}", a);
}

fn change_truth(x: bool) -> bool {
    !x
}
```

もし私たちが`Copy`トレイトを実装していない型を使っていたならば、私たちは移転した値を使おうとしたため、コンパイルエラーが出ていたでしょう。

```text
error: use of moved value: `a`
println!("{}", a);
               ^
```

私たちはあなた独自の`Copy`型を作る方法を[トレイト][traits]セクションで議論するでしょう。

[traits]: traits.html

# もっとたくさんの所有権

もちろん、もし私たちが所有権を私たちの書く全ての関数で返さなければならないのであれば、こうなります。

```rust
fn foo(v: Vec<i32>) -> Vec<i32> {
    // do stuff with v

    // hand back ownership
    v
}
```

これは非常に退屈になるでしょう。
私たちがもっとたくさんのものの所有権を受け取れば、それはもっと悪くなります。

```rust
fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {
    // do stuff with v1 and v2

    // hand back ownership, and the result of our function
    (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);
```

うわあ！　
戻り値の型、リターン行、関数呼出しがもっと複雑になります。

幸運なことに、Rustはボローイングという機能を提供します。それはこの問題を解決するために私たちを手助けします。
それは次のセクションの話題です！
