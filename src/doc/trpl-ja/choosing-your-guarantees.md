% 保証範囲の選択

Rustの重要な特長の1つは、プログラムのコストと保証を私たちが制御できるということです。

Rustの標準ライブラリーには、様々な「ラッパー型」の抽象があり、それらはコスト、人間工学、保証の間の多数のトレードオフをまとめています。
それらの多くでは実行時間とコンパイル時間のどちらかを選ばなければなりません。
このセクションでは、いくつかの抽象を選び、詳細に説明します。

先に進む前に、Rustにおける[所有権][ownership]と[ボローイング][borrowing]について読んでおくことを強く推奨します。

[ownership]: ownership.html
[borrowing]: references-and-borrowing.html

# 基本的なポインター型

## `Box<T>`

[`Box<T>`][box]は「所有される」ポインター、すなわち「ボックス」です。
それは中身のデータへの参照を渡すことができますが、そのデータの唯一の所有者です。
特に、次のことを考えましょう。

```rust
let x = Box::new(1);
let y = x;
// x no longer accessible here
```

ここで、そのボックスは`y`に _移転_ されました。
`x`はもはやそれを所有していないので、これ以降、コンパイラーはプログラマーが`x`を使うことを許しません。
同様に、ボックスはそれを戻すことで関数の _外_ に移転させることもできます。

（移転されていない）ボックスがスコープから外れると、デストラクターが実行されます。
それらのデストラクターは中身のデータを解放するように注意します。

これは動的割当ての0コストの抽象化です。
もしあなたがヒープにメモリーを割り当てたくて、そのメモリーへのポインターを安全に渡したいのであれば、これは理想的です。
あなたはコンパイル時にチェックされる通常のボローイングのルールに基づいてこれへの参照を共有することが許されているだけだということに注意しましょう。

[box]: ../std/boxed/struct.Box.html

## `&T`と`&mut T`

参照にはイミュータブルな参照とミュータブルな参照がそれぞれあります。
それらは「読み書きロック」パターンに従います。それは、あるデータへのミュータブルな参照を1つだけ持つこと、又は複数のイミュータブルな参照を持つことはあり得るが、その両方を持つことはあり得ないというようなことです。
この保証はコンパイル時に強制され、目に見えるような実行時のコストは発生しません。
多くの場合、それら2つのポインター型は低コストの参照をコードのセクション間で共有するには十分です。

それらのポインターを関連付けられている生存期間を超えて生存するような方法でコピーすることはできません。

## `*const T`と`*mut T`

関連付けられた生存期間や所有権を持たない、C的な生のポインターがあります。
それらはメモリーのある場所を何の制約もなく単に指示します。
それらの提供する唯一の保証は、`unsafe`であるとマークされたコードの外ではそれらが参照解決できないということです。

それらは`Vec<T>`のような安全で低コストな抽象を構築するときには便利ですが、安全なコードの中では避けるべきです。

## `Rc<T>`

これは、私たちがカバーする中では初めての、実行時にコストの発生するラッパーです。

[`Rc<T>`][rc]は参照カウンターを持つポインターです。
言い換えると、これによって私たちはあるデータへの複数の「所有する」ポインターを持つことができるようになるということです。そして、全てのポインターがスコープから外れたとき、そのデータは削除されます（デストラクターが実行されます）。

内部的には、それは共有「参照カウント」（refcountとも呼ばれます）を持っています。それは、`Rc`がクローンされる度に1増加し、`Rc`がスコープから外れる度に1減少します。
`Rc<T>`の主な責務は、共有データのデストラクターが呼び出されることを保証することです。

ここでの中身のデータはイミュータブルで、もし循環参照が起きてしまったら、そのデータはメモリーリークを起こすでしょう。
もし循環してもメモリーリークを起こさないデータを私たちが求めるのであれば、私たちにはガベージコレクターが必要です。

#### 保証

ここで提供される主な保証は、それに対する全ての参照がスコープから外れるまではデータが破壊されないということです。

これは私たちが（読込専用の）あるデータについて動的割当てを行いたいとき、そのデータをあなたのプログラムの様々な部分で共有したいのだけれども、どの部分が最後にポインターを使い終わるのかがはっきりしないときに使われるべきです。
それは`&T`が正しさを静的にチェックすることが不可能なとき、又はプログラマーがそれを使うために開発コストを費やすことを望まないような極めて非人間工学的なコードを作っているときに、`&T`の有望な代替品です。

このポインターはスレッドセーフでは _ありません_ 。Rustはそれを他のスレッドに対して送ったり共有したりはしません。
これによって、それらが不要な状況でのアトミック性のためのコストを省くことができます。

姉妹となるこれのスマートポインターとして`Weak<T>`があります。
これは所有せず、ボローもしないスマートポインターです。
それは`&T`とも似ていますが、生存期間による制約がありません。`Weak<T>`は永遠に生存することができます。
しかし、これは所有する`Rc`の生存期間を超えて生存する可能性があるため、中身のデータへのアクセスが失敗し、`None`を戻すという可能性はあります。
これは循環するデータ構造やその他のものについて便利です。

#### コスト

メモリーに関する限り、`Rc<T>`の割当ては1回です。ただし、普通の`Box<T>`と比べると
（「強い」参照カウントと「弱い」参照カウントのために）、2ワード余分に（つまり、2つの`usize`の値）割り当てます。

`Rc<T>`では、それをクローンしたりそれがスコープから外れたりする度に参照カウントを増減するための計算コストが掛かります。
クローンはディープコピーではなく、それが単に内部の参照カウントを1増加させ、`Rc<T>`のコピーを返すだけだということに注意しましょう。

[rc]: ../std/rc/struct.Rc.html

# セル型

`Cell`は内的ミュータビリティーを提供します。
言い換えると、それらはその型がミュータブルな形式を持たないものであったとしても（例えば、それが`&`ポインターや`Rc<T>`の参照先であるとき）、中身のデータを操作することができるということです。

[`cell`モジュールのドキュメントには、それらについての非常によい説明があります][cell-mod]。

それらの型は _一般的には_ 構造体のフィールドで見られますが、他の場所でも見られるかもしれません。

## `Cell<T>`

[`Cell<T>`][cell]は0コストで内的ミュータビリティーを提供するものですが、`Copy`型のためだけのものです。
コンパイラーはスタック上にある中身のデータの所有する全てのデータを認識しています。そのため、単純にデータが置き換えられることによって参照先のデータがメモリーリークを起こす（又はもっと悪いことも！）心配はありません。

このラッパーを使うことで、あなたの維持している不変性に違反してしまう可能性もあるので、それを使うときには注意しましょう。
もしフィールドが`Cell`でラップされているならば、そのデータの塊はミュータブルで、あなたが最初にそれを読み込んだときとそれを使おうと思ったときで同じままだとは限らないということのよい目印になります。

```rust
use std::cell::Cell;

let x = Cell::new(1);
let y = &x;
let z = &x;
x.set(2);
y.set(3);
z.set(4);
println!("{}", x.get());
```

ここでは私たちが同じ値を様々なミュータブルな参照から変更できるということに注意しましょう。

これには次のものと同じ実行時のコストが掛かります。

```rust,ignore
let mut x = 1;
let y = &mut x;
let z = &mut x;
x = 2;
*y = 3;
*z = 4;
println!("{}", x);
```

しかし、それには実際に正常にコンパイルできるという追加の利点があります。

#### 保証

これは「ミュータブルなエイリアスはない」という制約を、それが不要な場所において緩和します。
しかし、これはその制約が提供する保証をも緩和してしまいます。もしあなたの不変性が`Cell`に保存されているデータに依存しているのであれば、あなたは注意すべきです。

これは`&`や`&mut`の静的なルールの下では簡単な方法がない場合に、プリミティブやその他の`Copy`型を変更するのに便利です。

`Cell`によってあなたは安全な方法で自由に変更できるようなデータへの内部の参照を得られるわけではありません。

#### コスト

`Cell<T>`の使用に実行時のコストは掛かりません。ただし、もしあなたがそれを大きな（`Copy`の）構造体をラップするために使っているのであれば、代わりに個々のフィールドを`Cell<T>`でラップする方がよいかもしれません。そうしなければ、各書込みが構造体の完全コピーを発生させることになるからです。

## `RefCell<T>`

[`RefCell<T>`][refcell]もまた内的ミュータビリティーを提供するものですが、`Copy`型に限定されません。

その代わり、それには実行時のコストが掛かります。
`RefCell<T>`は読み書きロックパターンを実行時に（シングルスレッドのミューテックスのように）強制します。この点が、それをコンパイル時に行う`&T`や`&mut T`とは異なります。
これは`borrow()`関数と`borrow_mut()`関数によって行われます。それらは内部の参照カウントを変更し、それぞれイミュータブル、ミュータブルに参照解決することのできるスマートポインターを戻します。
参照カウントはスマートポインターがスコープから外れたときに元に戻されます。
このシステムによって、私たちはミュータブルなボローが有効なときには決してその他のボローが有効にならないということを動的に保証することができます。
もしプログラマーがそのようなボローを作ろうとすれば、スレッドはパニックするでしょう。

```rust
use std::cell::RefCell;

let x = RefCell::new(vec![1,2,3,4]);
{
    println!("{:?}", *x.borrow())
}

{
    let mut my_ref = x.borrow_mut();
    my_ref.push(1);
}
```

`Cell`と同様に、これは主に、ボローチェッカーを満足させることが困難、又は不可能な状況で便利です。
一般的に、私たちはそのような変更はネストした形式では発生しないと考えていますが、それをチェックすることはよいことです。

大きく複雑なプログラムにとって、物事を単純にするために何かを`RefCell`の中に入れることは便利です。
例えば、Rustコンパイラーの内部の[`ctxt`構造体][ctxt]にあるたくさんのマップはこのラッパーの中にあります。
それらは（初期化の直後ではなく生成の過程で）一度だけ変更されるか、又はきれいに分離された場所で数回変更されます。
しかし、この構造体はあらゆる場所で全般的に使われているので、ミュータブルなポインターとイミュータブルなポインターとをジャグリング的に扱うのは難しく（あるいは不可能で）、おそらく拡張の困難な`&`ポインターのスープになってしまいます。

一方、`RefCell`はそれらにアクセスするための（0コストではありませんが）低コストの方法です。
将来、もし誰かが既にボローされたセルを変更しようとするコードを追加すれば、それは（普通は確定的に）パニックを引き起こすでしょう。これは、その違反したボローまで遡ることができます。

同様に、ServoのDOMではたくさんの変更が行われるようになっていて、そのほとんどはDOM型にローカルです。しかし、そのいくつかはDOMと変更された様々なものとの間での食い違いを生じさせます。
全ての変更をガードするために`RefCell`と`Cell`を使うことで、私たちはあらゆる場所でのミュータビリティーについて心配する必要がなくなり、それは同時に、変更が _実際に_ 起こっている場所を強調してくれます。

もし`&`ポインターを使ってもっと単純に解決できるのであれば、`RefCell`は避けるべきであるということに注意しましょう。

#### 保証

`RefCell`はミュータブルなエイリアスを作らせないという _静的な_ 制約を緩和し、それを _動的な_ 制約に置き換えます。
そのため、その保証は変わりません。

#### コスト

`RefCell`は割当てを行いませんが、データとともに（サイズ1ワードの）追加の「ボロー状態」の表示を持っています。

実行時には、各ボローが参照カウントの変更又はチェックを発生させます。

[cell-mod]: ../std/cell/
[cell]: ../std/cell/struct.Cell.html
[refcell]: ../std/cell/struct.RefCell.html
[ctxt]: ../rustc/middle/ty/struct.ctxt.html

# 同期型

前に挙げた型の多くはスレッドセーフな方法で使うことができません。
特に`Rc<T>`と`RefCell<T>`は両方とも非アトミックな参照カウント（ _アトミックな_ 参照カウントとは、データ競合を発生させることなく複数のスレッドから増加させることができるもののことです）を使っていて、この方法で使うことができません。
これによってそれらを低コストで使うことができるのですが、私たちにはそれらのスレッドセーフなバージョンも必要です。
それらは`Arc<T>`、`Mutex<T>`、`RwLock<T>`という形式で存在します。

非スレッドセーフな型はスレッド間で送ることが _できません_ 。
これはコンパイル時にチェックされます。

[sync][sync]モジュールには並行プログラミングのための便利なラッパーがたくさんありますが、以下では有名なものだけをカバーします。

[sync]: ../std/sync/index.html

## `Arc<T>`

[`Arc<T>`][arc]はアトミックな参照カウントを使う`Rc<T>`の別バージョンです（そのため、"Arc"なのです）。
これはスレッド間で自由に送ることができます。

C++の`shared_ptr`は`Arc`と似ていますが、C++の場合、中身のデータは常にミュータブルです。
C++と同じセマンティクスで使うためには、私たちは`Arc<Mutex<T>>`、`Arc<RwLock<T>>`、`Arc<UnsafeCell<T>>`を使うべきです[^4]（`UnsafeCell<T>`はどんなデータでも持つことができ、実行時のコストも掛かりませんが、それにアクセスするためには`unsafe`ブロックが必要というセル型です）。
最後のものは、その使用がメモリーをアンセーフにしないことを私たちが確信している場合にだけ使うべきです。
次のことを覚えましょう。構造体に書き込むのはアトミックな作業ではなく、`vec.push()`のような多くの関数は内部でメモリーの再割当てを行い、アンセーフな挙動を引き起こす可能性があります。そのため単調増加であるということだけでは`UnsafeCall`を正当化するには十分ではありません。

[^4]: `Arc<UnsafeCell<T>>`は`Send`や`Sync`ではないため、実際にはコンパイルできません。しかし、私たちは`Arc<Wrapper<T>>`を得るために、手動でそれを`Send`と`Sync`を実装した型でラップすることができます。ここでの`Wrapper`は`struct Wrapper<T>(UnsafeCell<T>)`です。

#### 保証

`Rc`のように、これは最後の`Arc`がスコープから外れたときに（循環がなければ）中身のデータのためのデストラクターが実行されることを（スレッドセーフに）保証します。

#### コスト

これには参照カウントの変更（これは、それがクローンされたりスコープから外れたりする度に発生します）にアトミック性を使うための追加のコストが掛かります。
シングルスレッドにおいて、データを`Arc`から共有するのであれば、可能な場合は`&`ポインターを共有する方が適切です。

[arc]: ../std/sync/struct.Arc.html

## `Mutex<T>`と`RwLock<T>`

[`Mutex<T>`][mutex]と[`RwLock<T>`][rwlock]はRAIIガード（ガードとは、ロックのようにそれらのデストラクターが呼び出されるまである状態を保持するオブジェクトのことです）による相互排他を提供します。
それらの両方とも、私たちがその`lock()`を呼び出すまでミューテックスは不透明です。その時点で、スレッドはロックが得られ、ガードが戻されるまでブロックします。
このガードを使うことで、中身のデータに（ミュータブルに）アクセスできるようになり、ロックはガードがスコープから外れたときに解放されます。

```rust,ignore
{
    let guard = mutex.lock();
    // guard dereferences mutably to the inner type
    *guard += 1;
} // lock released when destructor runs
```

`RwLock`には複数の読込みを効率化するという追加の利点があります。
それはライターのない限り常に、共有されたデータに対する複数のリーダーを安全に持つことができます。そして、`RwLock`によってリーダーは「読込みロック」を取得できます。
このようなロックは並行に取得することができ、参照カウントによって追跡することができます。
ライターは「書込みロック」を取得する必要があります。「書込みロック」はすべてのリーダーがスコープから外れたときにだけ取得できます。

#### 保証

それらのどちらもスレッド間での安全で共有されたミュータビリティーを提供しますが、それらはデッドロックしがちです。
型システムによって、一定レベルでの追加のプロトコルの安全性を得ることができます。

#### コスト

それらはロックを保持するために内部でアトミック的な型を使います。それにはかなりコストが掛かります（それらは仕事が終わるまで、プロセッサー中のメモリー読込み全てをブロックする可能性があります）。
たくさんの並行なアクセスが起こる場合には、それらのロックを待つことが遅くなる可能性があります。

[rwlock]: ../std/sync/struct.RwLock.html
[mutex]: ../std/sync/struct.Mutex.html
[sessions]: https://github.com/Munksgaard/rust-sessions

# 合成

Rustのコードを読むときに一般的な悩みは、`Rc<RefCell<Vec<T>>>`のような型（又はそのような型をもっと複雑な合成）です。
その合成が何をしているのか、なぜ作者はこんなものを選んだのか（そして、自分のコード内でいつこんな合成を使うべきなのか）ということは、常に明らかなわけではありません。

普通、それは不要なコストを支払うことなく、あなたが必要とする保証を互いに組み合わせた場合です。

例えば、`Rc<RefCell<T>>`はそんな合成の1つです。
`Rc<T>`そのものはミュータブルに参照解決することができません。`Rc<T>`は共有を提供し、共有されたミュータビリティーはアンセーフな挙動に繋がる可能性があります。そのため、動的に証明された共有されたミュータビリティーを得るために、私たちは`RefCell<T>`を中に入れます。
これで私たちは共有されたミュータブルなデータを持ちますが、それは（リーダーはなしで）ライターが1つだけ、又はリーダーが複数という方法で共有することになります。

今度は、私たちはこれをさらに次の段階に進めて、`Rc<RefCell<Vec<T>>>`や`Rc<Vec<RefCell<T>>>`を持つことができます。
それらは両方とも共有できるミュータブルなベクターですが、同じではありません。

1つ目について、`RefCell<T>`は`Vec<T>`をラップしているので、その`Vec<T>`全体がミュータブルです。
同時に、それらは特定の時間において`Vec`全体の唯一のミュータブルなボローになり得ます。
これは、あなたのコードがそのベクターの別の要素で、別の`Rc`ハンドルから同時には動作しないということを意味します。
しかし、私たちは好きなように`Vec<T>`に対してプッシュやポップを行うことができます。
これはボローチェックが実行時に行われるという点で`&mut Vec<T>`と同様です。

2つ目について、ボローイングは個々の要素に対して行われますが、ベクター全体がイミュータブルになります。
そのため、私たちは異なる要素を別々にボローすることができますが、ベクターに対するプッシュやポップを行うことはできません。
これは`&mut [T]`[^3]と同じですが、やはりボローチェックは実行時に行われます。

並行プログラムでは、私たちは`Arc<Mutex<T>>`と似た状況に置かれます。それは共有されたミュータビリティーと所有権を提供します。

それらを使ったコードを読むときには、1行1行進み、提供される保証とコストを見ましょう。

合成された型を選択するときには、私たちはその逆に考えなければなりません。私たちの必要とする保証が何であるか、私たちが必要とする合成がどの点にあるのかを理解しましょう。
例えば、もし`Vec<RefCell<T>>`と`RefCell<Vec<T>>`のどちらかを選ぶのであれば、私たちは前の方で行ったようにトレードオフを理解し、選ばなければなりません。

[^3]: `&[T]`と`&mut [T]`は _スライス_ です。それらはポインターと長さを持ち、ベクターや配列の一部を参照することができます。
`&mut [T]`ではその要素を変更できますが、その長さは変更することができません。
