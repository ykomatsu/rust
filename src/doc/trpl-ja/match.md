% マッチ

しばしば、あなたは2つ以上の採り得る選択肢を持つため、単純な[`if`][if]/`else`は十分ではありません。
また、条件は非常に複雑になることがあります。
Rustは`match`キーワードを持ちます。それによってあなたは複雑な`if`/`else`のグループをより強力なものに置き換えることができるようになります。
これを見ましょう。

```rust
let x = 5;

match x {
    1 => println!("one"),
    2 => println!("two"),
    3 => println!("three"),
    4 => println!("four"),
    5 => println!("five"),
    _ => println!("something else"),
}
```

[if]: if.html

`match`は式を受け取り、それからその値に基づいて分岐します。
ブランチの各「肢」は`val => expression`という形式です。
値がマッチするとき、その肢の式が評価されるでしょう。
それは`match`と呼ばれますが、それは「パターンマッチング」という用語のためです。`match`はパターンマッチングの実装です。
ここで利用可能な全てのパターンをカバーする[パターンについての1つのセクション][patterns]があります。

[patterns]: patterns.html

それでは、何が大きな利点なのでしょうか。
なるほど、それにはいくつかあります。
まず最初に、`match`は「網羅的チェック」を強制します。
あなたには最後の肢、アンダースコアの付いた肢が見えますか。
もし私たちがその肢を削除すれば、Rustは私たちにエラーを出します。

```text
error: non-exhaustive patterns: `_` not covered
```

言い換えれば、Rustは私たちに私たちが値を忘れていると教えようとしているということです。
`x`は整数なので、Rustはそれが別の値、例えば`6`などを持つ可能性があるということを知っています。
しかし、`_`がなければ、それにマッチする可能性のある肢がなくなるため、Rustはコードのコンパイルを拒絶します。
`_`は「キャッチオール肢」のように振る舞います。
もし他のどの肢にもマッチしなければ、`_`の付いた肢がマッチするでしょう。そして、私たちはこのキャッチオール肢を持つので、私たちはもう`x`の採り得る全ての値のための肢を持つことになります。そして、私たちのプログラムはコンパイルに成功するでしょう。

`match`は式でもあります。それは私たちがそれを`let`束縛の右辺や式が使われる場所で直接に使うことができるということを意味します。

```rust
let x = 5;

let number = match x {
    1 => "one",
    2 => "two",
    3 => "three",
    4 => "four",
    5 => "five",
    _ => "something else",
};
```

ときどきそれは何かをある型から別の型に変換するよい方法であることがあります。

# 列挙型でのマッチ

`match`キーワードのもう1つの重要な使い方は列挙型の採り得る値を処理することです。

```rust
enum Message {
    Quit,
    ChangeColor(i32, i32, i32),
    Move { x: i32, y: i32 },
    Write(String),
}

fn quit() { /* ... */ }
fn change_color(r: i32, g: i32, b: i32) { /* ... */ }
fn move_cursor(x: i32, y: i32) { /* ... */ }

fn process_message(msg: Message) {
    match msg {
        Message::Quit => quit(),
        Message::ChangeColor(r, g, b) => change_color(r, g, b),
        Message::Move { x: x, y: y } => move_cursor(x, y),
        Message::Write(s) => println!("{}", s),
    };
}
```
再びRustコンパイラーは網羅性をチェックします。そしてそれはあなたが列挙型の全てのバリアントにマッチする肢を持つことを要求します。
もしあなたがそれをしなければ、あなたが`_`を使わない限り、それはコンパイル時エラーをあなたに出すでしょう。

前の`match`の使い方と異なり、あなたはこれをするために普通の`if`文を使うことができません。
あなたは`match`の短縮形式のように見えることがある[`if let`][if-let]文を使うことができます。

[if-let]: if-let.html
