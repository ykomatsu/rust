% 生存期間

このガイドはRustの所有権システムの3つの発表の1つです。
これはRustの最も独特で注目されている機能です。そして、Rust開発者はそれについて高度に精通しておくべきです。
所有権はどのようにRustがその最大の目標、メモリー安全性を得るのかということです。
そこにはいくつかの別個の概念があり、各概念が独自の章を持ちます。

* 鍵となる概念、[所有権][ownership]
* [ボローイング][borrowing]、そしてそれらに関連する機能、「参照」
* あなたが今読んでいる、生存期間

それらの3つの章は関連していて、それらには順序があります。
あなたは所有権システムを完全に理解するために、3つ全てを必要とするでしょう。

[ownership]: ownership.html
[borrowing]: references-and-borrowing.html

# メタ

私たちが詳細に入る前に、所有権システムについての2つの重要な注意があります。

Rustは安全性とスピートに焦点を合わせます。
Rustはそれらの目標をたくさんの「0コストの抽象化」を通じて成し遂げます。それは、Rustでは抽象化を機能させるためのコストをできる限り小さくすることを意味します。
所有権システムは0コストの抽象化の主な例です。
私たちがこのガイドの中で話すであろう解析の全ては _コンパイル時に行われます_ 。
あなたはそれらのどの機能に対しても実行時のコストを全く支払いません。

しかし、このシステムはあるコストを持ちます。それは学習曲線です。
多くの新しいRustのユーザーは私たちが「ボローチェッカーとの戦い」と好んで呼ぶものを経験します。そこではRustコンパイラーが開発者が正しいと考えるプログラムをコンパイルすることを拒絶します。
所有権がどのように機能するのかについてのプログラマーのメンタルモデルがRustの実装する実際のルールにマッチしないため、これはしばしば起きます。
しかし、よいニュースがあります。より経験豊富なRustの開発者は次のことを報告します。一度彼らが所有権システムのルールとともにしばらく仕事をすれば、彼らがボローチェッカーと戦うことは少なくなっていくということです。

それを念頭に置いて、生存期間について学びましょう。

# 生存期間

他の誰かの所有するリソースへの参照の貸付けは複雑になることがあります。
例えば、この一連の作業を想像しましょう。

1. 私はある種のリソースへのハンドルを取得する
2. 私はあなたにリソースへの参照を貸し付ける
3. 私はリソースを使い終わり、それを解放することを決める一方、あなたはあなたの参照をまだ持っている
4. あなたはリソースを使うことを決める

あー！　
あなたの参照は不正なリソースを指示しています。
リソースがメモリーであるとき、これは指示先の不正なポインター又は「解放後の使用」と呼ばれます。

これを修正するために、私たちはステップ3の後にステップ4が絶対に起こらないようにしなければなりません。
Rustでの所有権システムはこれを生存期間と呼ばれる概念を通じて行います。それは参照が有効であるスコープを説明します。

私たちが引数として参照を受け取る関数を持つとき、私たちは参照の生存期間を黙示又は明示することができます。

```rust
// implicit
fn foo(x: &i32) {
}

// explicit
fn bar<'a>(x: &'a i32) {
}
```

`'a`は「生存期間a」と読みます。
技術的には参照は全てそれに関連する生存期間を持ちますが、一般的な場合にはコンパイラーが私たちにそれらを削除させてくれます（つまり、省略できるということです。[「生存期間の削除」][lifetime-elision]以下を見ましょう）。
しかし、私たちはそれに入る前に、明示の例を分解しましょう。

[lifetime-elision]: #user-content-lifetime-elision

```rust,ignore
fn bar<'a>(...)
```

私たちは前に[関数の構文][functions]について少し話しました。しかし、私たちは関数名の後の`<>`を議論しませんでした。
関数は`<>`の間に「ジェネリックパラメーター」を持つことができ、生存期間はその一種です。
私たちは他の種類のジェネリックを[本書の後][generics]で議論しますが、とりあえず、生存期間の面だけに焦点を合わせましょう。

[functions]: functions.html
[generics]: generics.html

私たちは`<>`を私たちの生存期間を宣言するために使います。
これは`bar`が1つの生存期間`'a`を持つことを意味します。
もし私たちが2つの参照引数を持っていたのならば、それはこのように見えたでしょう。

```rust,ignore
fn bar<'a, 'b>(...)
```

それから引数リストでは、私たちは私たちの名付けた生存期間を使います。

```rust,ignore
...(x: &'a i32)
```

もし私たちが`&mut`参照を欲しいのならば、私たちはこうしたでしょう。

```rust,ignore
...(x: &'a mut i32)
```

もしあなたが`&mut i32`を`&'a mut i32`と比較するならば、それらは同じです。それは生存期間`'a`が`&`と`mut i32`の間にこっそり入っているだけです。
私たちは`&mut i32`を「`i32`へのミュータブルな参照」のように読み、`&'a mut i32`を「生存期間`'a`を持つ`i32`へのミュータブルな参照」のように読みます。

# `struct`の中

[`struct`][structs]を使うとき、あなたは明示的な生存期間も必要とするでしょう。

```rust
struct Foo<'a> {
    x: &'a i32,
}

fn main() {
    let y = &5; // this is the same as `let _y = 5; let y = &_y;`
    let f = Foo { x: y };

    println!("{}", f.x);
}
```

[structs]: structs.html

あなたが見たとおり、`struct`も生存期間を持つことができます。
関数と同じ方法です。

```rust
struct Foo<'a> {
# x: &'a i32,
# }
```

生存期間を宣言します。

```rust
# struct Foo<'a> {
x: &'a i32,
# }
```

そしてそれを使います。
それではなぜ私たちはここで生存期間を必要とするのでしょうか。
私たちは`Foo`への全ての参照がそれの含む`i32`への参照より長く生存できないことを保証する必要があります。

## `impl`ブロック

`Foo`にメソッドを実装しましょう。

```rust
struct Foo<'a> {
    x: &'a i32,
}

impl<'a> Foo<'a> {
    fn x(&self) -> &'a i32 { self.x }
}

fn main() {
    let y = &5; // this is the same as `let _y = 5; let y = &_y;`
    let f = Foo { x: y };

    println!("x is: {}", f.x());
}
```

あなたが見たとおり、私たちは`Foo`の生存期間を`impl`行で宣言する必要があります。
私たちはちょうど関数のときのように`'a`を2回繰り返します。つまり、`impl<'a>`は生存期間`'a`を定義し、`Foo<'a>`はそれを使うのです。

## 複数の生存期間

もしあなたが複数の生存期間を持つのならば、あなたは同じ生存期間を複数回使うことができます。

```rust
fn x_or_y<'a>(x: &'a str, y: &'a str) -> &'a str {
#    x
# }
```

これは`x`と`y`が両方とも同じスコープで生存し、戻り値もそのスコープで生存することを示します。
もしあなたが`x`と`y`に違う生存期間を持たせたいのであれば、あなたは複数の生存期間パラメーターを使うことができます。

```rust
fn x_or_y<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {
#    x
# }
```

この例では`x`と`y`が異なる有効なスコープを持ちますが、戻り値は`x`と同じ生存期間を持ちます。

## スコープの考え方

生存期間についての考え方は参照の有効なスコープを見えるようにすることです。
例えばこうです。

```rust
fn main() {
    let y = &5;     // -+ y goes into scope
                    //  |
    // stuff        //  |
                    //  |
}                   // -+ y goes out of scope
```

私たちの`Foo`を追加するとこうなります。

```rust
struct Foo<'a> {
    x: &'a i32,
}

fn main() {
    let y = &5;           // -+ y goes into scope
    let f = Foo { x: y }; // -+ f goes into scope
    // stuff              //  |
                          //  |
}                         // -+ f and y go out of scope
```

私たちの`f`は`y`のスコープの中で生存するので、全て動きます。
もしそれがそうではなかったらどうでしょうか。
このコードは動かないでしょう。

```rust,ignore
struct Foo<'a> {
    x: &'a i32,
}

fn main() {
    let x;                    // -+ x goes into scope
                              //  |
    {                         //  |
        let y = &5;           // ---+ y goes into scope
        let f = Foo { x: y }; // ---+ f goes into scope
        x = &f.x;             //  | | error here
    }                         // ---+ f and y go out of scope
                              //  |
    println!("{}", x);        //  |
}                             // -+ x goes out of scope
```

ふう！　
ここであなたが見たとおり、`f`と`y`のスコープは`x`のスコープよりも小さいです。
しかし私たちが`x = &f.x`を実行するとき、私たちは`x`をまさにスコープから外れた何かの参照にします。

名前付生存期間はそれらのスコープに名前を与える方法です。
何かに名前を与えることはそれについて話をすることができるようになるための最初のステップです。

## 'static

「static」と名付けられた生存期間は特別な生存期間です。
それは何かがプログラム全体の生存期間を持つことを示します。
ほとんどのRustのプログラマーは文字列を扱うときに最初に`'static`に出会います。

```rust
let x: &'static str = "Hello, world.";
```

文字列リテラルは`&'static str`型を持ちます。なぜなら、参照は常に生存するからです。それらは最終的なバイナリーのデータセグメントに焼き付けられます。
もう1つの例はグローバルです。

```rust
static FOO: i32 = 5;
let x: &'static i32 = &FOO;
```

これはバイナリーのデータセグメントに`i32`を追加します。そして、`x`はそれへの参照です。

## 生存期間の削除

Rustは関数本文での強力なローカルの型推論をサポートします。しかし、要素のシグネチャーでは要素のシグネチャーだけに基づく型についての推論が許されていません。
しかし、人間工学的な推論のために、非常に制限された「生存期間の削除」と呼ばれる2番目の推論アルゴリズムが関数のシグネチャーでは適用されます。
それはシグネチャーの部品自体だけに基づき、関数本文には基づかずに、生存期間パラメーターだけを推論します。そしてそれはこれをたった3つの覚えやすく明確なルールに従って行います。
これは生存期間の削除を要素のシグネチャーを書くための省略表現にします。なぜなら、完全なローカルの推論のように関連する実際の型を隠すことができればいいのですが、それを適用することはできないからです。

生存期間の削除について話すとき、私たちは *入力生存期間* と *出力生存期間* という用語を使います。
*入力生存期間* は関数の引数に関連する生存期間で、 *出力生存期間* は関数の戻り値に関連する生存期間です。
例えば、この関数は入力生存期間を持ちます。

```rust,ignore
fn foo<'a>(bar: &'a str)
```

これは出力生存期間を持ちます。

```rust,ignore
fn foo<'a>() -> &'a str
```

これは両方の位置の生存期間を持ちます。

```rust,ignore
fn foo<'a>(bar: &'a str) -> &'a str
```

これが3つのルールです。

* 関数の引数の中の削除された各生存期間は別個の生存期間パラメーターになる
* もし入力生存期間が1つだけならば、削除されたかどうかにかかわらず、その生存期間はその関数の戻り値の中の削除された生存期間全てに割り当てられる
* もし入力生存期間が複数あるが、その1つが`&self`又は`&mut self`であれば、`self`の生存期間は削除された出力生存期間全てに割り当てられる

そうでないときは、出力生存期間の削除はエラーです。

### 例

これは削除された生存期間を持つ関数の例です。
私たちは削除された生存期間の各例をその展開した形式と組み合わせています。

```rust,ignore
fn print(s: &str); // elided
fn print<'a>(s: &'a str); // expanded

fn debug(lvl: u32, s: &str); // elided
fn debug<'a>(lvl: u32, s: &'a str); // expanded

// In the preceding example, `lvl` doesn’t need a lifetime because it’s not a
// reference (`&`). Only things relating to references (such as a `struct`
// which contains a reference) need lifetimes.

fn substr(s: &str, until: u32) -> &str; // elided
fn substr<'a>(s: &'a str, until: u32) -> &'a str; // expanded

fn get_str() -> &str; // ILLEGAL, no inputs

fn frob(s: &str, t: &str) -> &str; // ILLEGAL, two inputs
fn frob<'a, 'b>(s: &'a str, t: &'b str) -> &str; // Expanded: Output lifetime is ambiguous

fn get_mut(&mut self) -> &mut T; // elided
fn get_mut<'a>(&'a mut self) -> &'a mut T; // expanded

fn args<T:ToCStr>(&mut self, args: &[T]) -> &mut Command; // elided
fn args<'a, 'b, T:ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command; // expanded

fn new(buf: &mut [u8]) -> BufWriter; // elided
fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a>; // expanded
```
