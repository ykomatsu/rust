% プログラミング言語Rust

ようこそ！
本書ではあなたに[プログラミング言語Rust][rust]をお教えします。
Rustは安全性、速度、そして並行性という3つのゴールに焦点を合わせたシステムプログラミング言語です。
Rustはこれらのゴールをガベージコレクターなしで維持していて、他言語が得意でない多くの利用場面、例えば、他言語への組込み、限定されたスペースや時間で動かなくてはならないプログラム、そしてデバイスドライバーやオペレーティングシステムのような低レベルのコードの記述において便利な言語になっています。
Rustは、この領域を対象とする現在の言語を、実行時にオーバーヘッドを生じずにたくさんのコンパイル時の安全性チェックを行うことと同時に全てのデータ競合を削除することで改善しています。
Rustはまた、「0コストの抽象化」を実現することも目標としています。それらの抽象化の中には高レベル言語のものであるかのように感じられるものさえあるにもかかわらず、です。
それでも、Rustでは低レベル言語の行うような細かい制御も依然として許されています。

[rust]: https://www.rust-lang.org

「プログラミング言語Rust」は8つのセクションに分かれています。
この導入が1つ目です。
その後はこのようになっています。

* [始めましょう][gs] - Rustの開発のためにコンピューターをセットアップします。
* [Rustの学習][lr] - 小さなプロジェクトを通じてRustでのプログラミングを学びます。
* [Effective Rust][er] - すばらしいRustのコードを書くための高レベルの概念。
* [構文と意味][ss] - 小さな塊に分解した、Rustのそれぞれの要素。
* [Nightly Rust][nr] - 安定版ビルドにはまだ入っていない最新鋭の機能。
* [用語集][gl] - 本書で使われている用語のリファレンス。
* [参考文献][bi] - Rustの勢力の背景、Rustについての論文。

[gs]: getting-started.html
[lr]: learn-rust.html
[er]: effective-rust.html
[ss]: syntax-and-semantics.html
[nr]: nightly-rust.html
[gl]: glossary.html
[bi]: bibliography.html

この導入を読んだ後には、好みによって「Rustの学習」か「構文と意味」のどちらかに入りたくなるでしょう。もしあなたがプロジェクトから学びたいのであれば「Rustの学習」、小さく始めて、先に進む前に1つの概念を深く学びたいのであれば「構文と意味」です。
たくさんのハイパーリンクがそれらのパートを接続しています。

### 貢献

生成された本書のソースファイルはGitHubの[github.com/rust-lang/rust/tree/master/src/doc/trpl](https://github.com/rust-lang/rust/tree/master/src/doc/trpl)で見付けることができます。

## Rustの簡単な導入

Rustに興味を持ってもらえたでしょうか。
その強力さを少し披露するためにいくつかの小さなコード例を見てみましょう。

Rustの独自性を形成する主な概念は「所有権」と呼ばれるものです。
この小さな例について考えてみましょう。

```rust
fn main() {
    let mut x = vec!["Hello", "world"];
}
```

このプログラムは`x`と名付けられた[変数束縛][var]を作ります。
この束縛の値は`Vec<T>`、「ベクター」です。これは標準ライブラリーで定義された[マクロ][macro]を使って作ることができます。
このマクロは`vec`と呼ばれていて、マクロは`!`を付けて実行します。
これは、物事を明示せよというRustの一般原則に従っています。
マクロは関数呼出しよりもはるかに複雑なことができるので、見た目から異なっているのです。
`!`はパースの際の助けにもなり、ツールを書きやすくしてくれます。このこともまた重要です。

`mut`は`x`をミュータブルにします。Rustでは束縛はデフォルトでイミュータブルです。
このベクターは例の後で使います。

ここでは型注釈が不要だということに気が付くことに価値があります。
Rustは静的型付けですが、明示的に型注釈を付ける必要はありません。
Rustは静的型付けのパワーと型注釈の冗長さとのバランスを取るために型推論を行います。

Rustはヒープ割当てよりもスタック割当てを好みます。`x`はスタックに直接格納されます。
しかし、`Vec<T>`型はベクターの要素をヒープ上に割り当てます。
もし、この違いに慣れていないのであれば、今は無視しても構いませんし、[「スタックとヒープ」][heap]をチェックすることもできます。
システムプログラミング言語として、Rustではメモリーがどのように割り当てられるのかを制御することができます。しかし、私たちはまだ始めたところなので、それは大して重要ではありません。

[var]: variable-bindings.html
[macro]: macros.html
[heap]: the-stack-and-the-heap.html

前の方で、Rustでは「所有権」が鍵となる新しい概念だと言いました。
Rustの用語法では、`x`はそのベクターを「所有する」と言います。
これは、`x`がスコープから外れたとき、ベクターのメモリーは解放されるということを意味します。
これはガベージコレクターのようなメカニズムを通じて行われるのではなく、Rustのコンパイラーによって確定的に行われます。
言い換えれば、Rustでは、`malloc`や`free`のような関数を自分で呼び出すことはないということです。
いつメモリーの割当てや解放が必要になるかはコンパイラーが静的に決定し、コンパイラーがそれらの呼出しを挿入します。
過つは人の性ですが、コンパイラーは決して忘れません。

例に行を追加してみましょう。

```rust
fn main() {
    let mut x = vec!["Hello", "world"];

    let y = &x[0];
}
```

もう1つの束縛、`y`を作りました。
この場合、`y`はベクターの先頭の要素の「参照」です。
Rustの参照は他言語でのポインターと似ていますが、コンパイル時の安全性チェックが加えられています。
所有権システムにおいて、参照は[「ボローイング」][borrowing]と関係します。参照は、所有するものではなく、指示するものです。
その違いは、参照がスコープから外れたとき、指示先のメモリーを解放しないことです。
もし解放してしまえば、二重に解放してしまうことになるので、まずいのです！

[borrowing]: references-and-borrowing.html

3行目を追加しましょう。
全く問題ないように見えますが、これはコンパイルエラーを引き起こします。

```rust,ignore
fn main() {
    let mut x = vec!["Hello", "world"];

    let y = &x[0];

    x.push("foo");
}
```

`push`は他の要素をベクターの末尾に追加する、ベクターのメソッドです。
このプログラムをコンパイルしようとすると、エラーが出ます。

```text
error: cannot borrow `x` as mutable because it is also borrowed as immutable
    x.push("foo");
    ^
note: previous borrow of `x` occurs here; the immutable borrow prevents
subsequent moves or mutable borrows of `x` until the borrow ends
    let y = &x[0];
             ^
note: previous borrow ends here
fn main() {

}
^
```

うわっ！
Rustのコンパイラーはときどき非常に詳細なエラーを出してくれますが、これはその1つです。
エラーに書かれているとおり、作った束縛をミュータブルにしたのに、まだ`push`を呼び出すことができません。
これは、ベクター`y`の要素の参照を既に持っていることが原因です。
既に参照が存在するのに、それをミュータブルにするのは危険です。なぜなら、参照を不正にしてしまうかもしれないからです。
今回の場合で言えば、ベクターを作ったときには2つの要素についてスペースを割り当てただけでした。
3つ目を追加することは全ての要素のための新しいメモリーの塊を割り当てて、古い値をそこにコピーして、そしてそのメモリーを指示する内部のポインターを更新することを意味します。
それは全てうまく動きます。
問題は、`y`が更新されず、「指示先不明のポインター」になってしまうことにあります。
それはいけません。
この場合、`y`をどのように使ってもエラーになってしまうので、コンパイラーはこれを検出するのです。

この問題はどうすれば解決できるのでしょうか。
採り得る方法は2つです。
1つ目は参照を使うのではなくコピーを作る方法です。

```rust
fn main() {
    let mut x = vec!["Hello", "world"];

    let y = x[0].clone();

    x.push("foo");
}
```

Rustはデフォルトで[ムーブセマンティクス][move]を採用しているので、あるデータのコピーを作りたいときは、`clone()`メソッドを呼び出します。
この例では、`y`はもう`x`を保存したベクターへの参照ではありませんが、その先頭の要素、`"Hello"`のコピーになります。
参照を持たなくなったのですから、`push()`はちゃんと動きます。

[move]: ownership.html#move-semantics

もし、本当に参照が必要ならば、別の選択肢が必要です。変更をしようとする前に参照がスコープから確実に外れているようにするのです。
それはこのようになります。

```rust
fn main() {
    let mut x = vec!["Hello", "world"];

    {
        let y = &x[0];
    }

    x.push("foo");
}
```

1組の追加の波括弧で内側のスコープを作りました。
`push()`を呼び出す前に`y`はスコープから外れるので、全てうまく動きます。

この所有権の概念は、指示先不明のポインターを避けるためだけに有効なのではありません。イテレーターの不正、並行性、そしてその他の関連する問題全体に対して有効なのです。
