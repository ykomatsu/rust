% プログラミング言語Rust

ようこそ！　
本書では、あなたに[プログラミング言語Rust][rust]について解説します。
Rustは3つの目標に焦点を合わせたシステムプログラミング言語です。その目標とは、安全性、速度、並行性の3つです。
Rustはこれらの目標をガベージコレクターなしで維持しています。そのことによって、Rustは他の言語が得意としない多くの利用場面で便利な言語になっています。例えば、他の言語への組込み、限定されたスペースや時間で動かなくてはならないプログラム、デバイスドライバーやオペレーティングシステムのような低レベルのコードの記述です。
Rustは、この領域を対象とする現在の言語を、実行時にオーバーヘッドを生じることなくたくさんのコンパイル時の安全性チェックを行うことと同時に、全てのデータ競合を削除することで改善しています。
Rustはまた、「0コストの抽象化」の実現も目標としています。それらの抽象化の中には高レベル言語のものであるかのように感じられるものさえあるにもかかわらずです。
それでも、Rustでは低レベル言語の行うような細かい制御も依然として許されています。

[rust]: https://www.rust-lang.org

「プログラミング言語Rust」は8つのセクションに分かれています。
この導入が1つ目です。
その後はこのようになっています。

* [始めましょう][gs] - Rustの開発のためにコンピューターをセットアップする。
* [Rustの学習][lr] - 小さなプロジェクトを通じてRustでのプログラミングを学ぶ。
* [Effective Rust][er] - すばらしいRustのコードを書くための高レベルの概念。
* [構文と意味][ss] - 小さな塊に分解した、Rustのそれぞれの要素。
* [Nightly Rust][nr] - 安定ビルドにはまだ入っていない最新鋭の機能。
* [用語集][gl] - 本書で使われている用語のリファレンス。
* [参考文献][bi] - Rustの勢力の背景、Rustについての論文。

[gs]: getting-started.html
[lr]: learn-rust.html
[er]: effective-rust.html
[ss]: syntax-and-semantics.html
[nr]: nightly-rust.html
[gl]: glossary.html
[bi]: bibliography.html

この導入を読んだ後、あなたはその好みによって「Rustの学習」か「構文と意味」のどちらかに進みたくなるでしょう。もしあなたがプロジェクトから学びたいのであれば「Rustの学習」、小さく始めて、先に進む前に1つの概念を深く学びたいのであれば「構文と意味」です。
たくさんのハイパーリンクがそれらのパートを接続しています。

### 貢献

本書を生成するためのソースファイルはGitHubの[github.com/rust-lang/rust/tree/master/src/doc/trpl](https://github.com/rust-lang/rust/tree/master/src/doc/trpl)に置いてあります。[^trpl-ja]

[^trpl-ja]: 訳注。日本語訳のソースファイルはGitHubの[github.com/ykomatsu/rust/tree/trpl-ja/src/doc/trpl-ja](https://github.com/ykomatsu/rust/tree/trpl-ja/src/doc/trpl-ja)に置いてあります。

## Rustの簡潔な導入

Rustはあなたの興味を引くような言語だったでしょうか。
その強力さを少し披露するためにいくつかの小さなコード例を見ましょう。

Rustの独自性を形成する主な概念は「所有権」と呼ばれるものです。
この小さな例について考えましょう。

```rust
fn main() {
    let mut x = vec!["Hello", "world"];
}
```

このプログラムは`x`と名付けられた[変数束縛][var]を作ります。
この束縛の値は`Vec<T>`、「ベクター」です。私たちはこれを標準ライブラリーで定義された[マクロ][macro]を使って作ることができます。
このマクロは`vec`と呼ばれていて、私たちはマクロに`!`を付けて実行します。
これは、物事を明示せよというRustの一般原則に従っています。
マクロは関数呼出しよりもはるかに複雑なことができるので、見た目から異なっているのです。
`!`はパースの際の助けにもなり、ツールを書きやすくしてくれます。このこともまた重要です。

私たちは`x`をミュータブルにするために`mut`を使います。Rustでは束縛はデフォルトでイミュータブルです。
私たちはこのベクターを後の方の例で変更します。

ここで、私たちが型注釈を付ける必要がなかったということに気が付くことには価値があります。Rustは静的型付けですが、私たちが明示的に型注釈を付ける必要はありません。
Rustは静的型付けの力と型注釈の冗長さとのバランスを取るために型推論を行います。

Rustはヒープ割当てよりもスタック割当てを好みます。`x`はスタックに直接に格納されます。
しかし、`Vec<T>`型はベクターの要素をヒープ上に割り当てます。
もし、あなたがこの違いに慣れていないのであれば、今は無視しても構いません。又は[「スタックとヒープ」][heap]をチェックしましょう。
システムプログラミング言語として、Rustでは私たちはメモリーがどのように割り当てられるのかを制御することができます。しかし、私たちがまだ始めたばかりのときには、それは大して重要ではありません。

[var]: variable-bindings.html
[macro]: macros.html
[heap]: the-stack-and-the-heap.html

前の方で、私たちは、Rustでは「所有権」が鍵となる新しい概念だと言いました。
Rustの用語法では、`x`はそのベクターを「所有する」と言います。
これは、`x`がスコープから外れたとき、ベクターのメモリーは解放されるということを意味します。
これはガベージコレクターのようなメカニズムを通じて行われるのではなく、Rustのコンパイラーによって確定的に行われます。
言い換えると、Rustでは、私たちは`malloc`や`free`のような関数を自分で呼び出すことはないということです。コンパイラーは、いつメモリーの割当てや解放が必要になるかを静的に決定し、それらの呼出しを挿入します。
過つは人の性ですが、コンパイラーは決して忘れません。

私たちの例に行を追加しましょう。

```rust
fn main() {
    let mut x = vec!["Hello", "world"];

    let y = &x[0];
}
```

私たちはもう1つの束縛、`y`を作りました。
この場合、`y`はベクターの先頭の要素の「参照」です。
Rustの参照は他の言語でのポインターと似ていますが、コンパイル時の安全性チェックが加えられています。
参照は、それを所有するのではなく参照する、[「ボローイング」][borrowing]によって所有権システムと関係します。
その違いは、参照がスコープから外れたとき、指示先のメモリーを解放しないことです。
もし解放してしまえば、二重に解放してしまうことになります。それはまずいです！　

[borrowing]: references-and-borrowing.html

3行目を追加しましょう。
全く問題ないように見えますが、これはコンパイルエラーを引き起こします。

```rust,ignore
fn main() {
    let mut x = vec!["Hello", "world"];

    let y = &x[0];

    x.push("foo");
}
```

`push`は他の要素をベクターの末尾に追加する、ベクターのメソッドです。
私たちがこのプログラムをコンパイルしようとすると、エラーが出ます。

```text
error: cannot borrow `x` as mutable because it is also borrowed as immutable
    x.push("foo");
    ^
note: previous borrow of `x` occurs here; the immutable borrow prevents
subsequent moves or mutable borrows of `x` until the borrow ends
    let y = &x[0];
             ^
note: previous borrow ends here
fn main() {

}
^
```

おおっ！　
Rustのコンパイラーはときどき非常に詳細なエラーを出してくれますが、これはその1つです。
エラーに書かれているとおり、私たちは束縛をミュータブルにしたのに、まだ`push`を呼び出すことができません。
これは、私たちがベクター`y`の要素の参照を既に持っていることが原因です。
既に参照が存在するのに、それをミュータブルにするのは危険です。なぜなら、私たちは参照を不正にしてしまうかもしれないからです。
特に今回の場合、私たちがベクターを作ったときには、2つの要素についてスペースを割り当てただけでした。
3つ目を追加することは全ての要素のための新しいメモリーの塊を割り当てて、古い値をそこにコピーして、そしてそのメモリーを指示する内部のポインターを更新することを意味します。
それは全てうまく動きます。
問題は、`y`が更新されず、私たちの持つポインターが「指示先の不正なポインター」になってしまうことにあります。
それはまずいです。
この場合、`y`をどのように使ってもエラーになってしまうので、コンパイラーは私たちのためにこれを検出するのです。

私たちはこの問題をどうすれば解決できるでしょうか。
私たちの採り得る方法は2つです。
1つ目は参照を使うのではなくコピーを作る方法です。

```rust
fn main() {
    let mut x = vec!["Hello", "world"];

    let y = x[0].clone();

    x.push("foo");
}
```

Rustはデフォルトで[ムーブセマンティクス][move]を採用しています。そのため、私たちがあるデータのコピーを作りたいときには、`clone()`メソッドを呼び出します。
この例では、`y`はもう`x`を保存したベクターへの参照ではなく、その先頭の要素、`"Hello"`のコピーです。
私たちはもう参照を持っていないのですから、`push()`はちゃんと動きます。

[move]: ownership.html#move-semantics

もし、私たちが本当に参照を必要とするならば、別の選択肢が必要です。変更をしようとする前に私たちの参照がスコープから確実に外れているようにするのです。
それはこのようになります。

```rust
fn main() {
    let mut x = vec!["Hello", "world"];

    {
        let y = &x[0];
    }

    x.push("foo");
}
```

私たちは波括弧の組を追加して内側にスコープを作りました。
私たちが`push()`を呼び出す前に`y`はスコープから外れるので、私たちは大満足です。

この所有権の概念は、指示先の不正なポインターを避けるためだけに有効なのではありません。イテレーターの不正、並行性、その他の関連する問題全体に対して有効なのです。
