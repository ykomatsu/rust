% プリミティブ型

Rust言語は「プリミティブ」であると考えられるかなりの数の型を持ちます。
これはそれらが言語に組み込まれていることを意味します。
標準ライブラリーも同様にそれらの型の上に構築されたかなりの数の便利な型を提供していて、Rustはそのような方法で構造化されていますが、それらの型は最もプリミティブです。

# ブーリアン

Rustは`bool`と名付けられた組込みのブーリアン型を持ちます。
それは`true`と`false`という2つの値を持ちます。

```rust
let x = true;

let y: bool = false;
```

ブーリアンの一般的な使い方は、[`if`条件][if]の中にあります。

[if]: if.html

あなたは`bool`のさらなるドキュメントを[標準ライブラリーのドキュメントの中][bool]で見付けることができます。

[bool]: ../std/primitive.bool.html

# `char`

`char`型は1つのユニコードのスカラー値を表現します。
あなたは`char`をクオート（`'`）で作ることができます。

```rust
let x = 'x';
let two_hearts = '💕';
```

いくつかの他の言語と異なり、これはRustの`char`が1バイトではなく4バイトであるということを意味します。

あなたは`char`のさらなるドキュメントを[標準ライブラリーのドキュメントの中][char]で見付けることができます。

[char]: ../std/primitive.char.html

# 数値型

Rustは符号ありと符号なし、固定長と可変長、浮動小数点数と整数というカテゴリーの中にたくさんの種類の数値型を持ちます。

それらの型はカテゴリーとサイズという2つの部分から成ります。
例えば、`u16`はサイズ16ビットで符号なしの型です。
ビット数を大きくすれば、あなたはより大きな数値を持てます。

もし数値リテラルがその型を推論させるものを全く持たないのであれば、それはデフォルトになります。

```rust
let x = 42; // x has type i32

let y = 1.0; // y has type f64
```

これは異なる数値型のリストにそれらの標準ライブラリーのドキュメントへのリンクを付けたものです。

* [i8](../std/primitive.i8.html)
* [i16](../std/primitive.i16.html)
* [i32](../std/primitive.i32.html)
* [i64](../std/primitive.i64.html)
* [u8](../std/primitive.u8.html)
* [u16](../std/primitive.u16.html)
* [u32](../std/primitive.u32.html)
* [u64](../std/primitive.u64.html)
* [isize](../std/primitive.isize.html)
* [usize](../std/primitive.usize.html)
* [f32](../std/primitive.f32.html)
* [f64](../std/primitive.f64.html)

それらをカテゴリー別に調べましょう。

## 符号ありと符号なし

整数型には符号ありと符号なしという2つの種類があります。
違いを理解するために、サイズ4ビットの数値を考えましょう。
符号あり4ビット整数は`-8`から`+7`までの数値を保存することができます。
符号ありの数値は「2の補数表現」を使います。
符号なし4ビット整数は、マイナスを保存する必要がないため、`0`から`+15`までの値を保存することができます。

符号なし（unsigned）型はそれらのカテゴリーに`u`を使い、符号あり型は`i`を使います。
`i`は「整数（integer）」の頭文字です。
そのため、`u8`は8ビット符号なし数値、`i8`は8ビット符号あり数値です。

## 固定長型

固定長型はそれらの表現の中に特定のビット長を持ちます。
正しいビット長は`8`、`16`、`32`、`64`です。
そのため、`u32`は符号なし32ビット整数、`i64`は符号あり64ビット整数です。

## 可変長型

Rustはそのサイズが実行しているマシンのポインターのサイズに依存する型も提供します。
それらの方はカテゴリーとして「サイズ（size）」を使い、符号ありと符号なしの種類があります。
これが`isize`と`usize`という2つの型を作ります。

## 浮動小数点型

Rustは`f32`と`f64`という2つの浮動小数点型を持ちます。
それらはIEEE-754単精度及び倍精度小数点数に対応します。

# 配列

多くのプログラミング言語のように、Rustは何かのシーケンスを表現するためのリスト型を持ちます。
最も基本的なものは *配列* 、固定サイズの同じ型の要素のリストです。
デフォルトでは、配列はイミュータブルです。

```rust
let a = [1, 2, 3]; // a: [i32; 3]
let mut m = [1, 2, 3]; // m: [i32; 3]
```

配列は`[T; N]`という型を持ちます。
私たちはこの`T`記法について[ジェネリックのセクションの中][generics]で話すでしょう。
`N`は配列の長さのためのコンパイル時の定数です。

配列の各要素を同じ値で初期化するための省略表現があります。
この例では、`a`の各要素は`0`で初期化されるでしょう。

```rust
let a = [0; 20]; // a: [i32; 20]
```

あなたは配列`a`の要素の個数を`a.len()`で得ることができます。

```rust
let a = [1, 2, 3];

println!("a has {} elements", a.len());
```

あなたは配列の特定の要素に *添字記法* でアクセスすることができます。

```rust
let names = ["Graydon", "Brian", "Niko"]; // names: [&str; 3]

println!("The second name is: {}", names[1]);
```

添字はほとんどのプログラミング言語と同じように0から始まります。そのため、最初の名前は`names[0]`で2つ目の名前は`names[1]`です。
前の例は`The second name is: Brian`とプリントします。
もしあなたが配列に含まれない添字を使おうとすると、エラーが出ます。配列アクセスは実行時に境界チェックを受けます。
他のシステムプログラミング言語では、そのような誤ったアクセスは多くのバグの源となります。

あなたは`array`のさらなるドキュメントを[標準ライブラリーのドキュメントの中][array]で見付けることができます。

[array]: ../std/primitive.array.html

# スライス

「スライス」は他のデータ構造への参照（又は「ビュー」）です。
それらはコピーすることなく配列の要素への安全で効率的なアクセスを許すために便利です。
例えば、あなたはメモリーに読み込んだファイルの1行だけを参照したいかもしれません。
本来、スライスは直接作られるのではなく、既存の変数束縛から作られます。
スライスは定義された長さを持ち、ミュータブルにもイミュータブルにもできます。

## スライスのインデックス

あなたは様々なものからスライスを作るために`&`と`[]`の組合せを使うことができます。
`&`はスライスが参照と同じであることを示し、`[]`はレンジ（range）を持ち、あなたにスライスの長さを定義させます。

```rust
let a = [0, 1, 2, 3, 4];
let complete = &a[..]; // A slice containing all of the elements in a
let middle = &a[1..4]; // A slice of a: just the elements 1, 2, and 3
```

スライスは型`&[T]`を持ちます。
私たちは[ジェネリック][generics]をカバーするときにその`T`について話すでしょう。

[generics]: generics.html

あなたは`slice`のさらなるドキュメントを[標準ライブラリーのドキュメントの中][slice]で見付けることができます。

[slice]: ../std/primitive.slice.html

# `str`

Rustの`str`型は最もプリミティブな文字列型です。
[サイズのない型][dst]のように、それはそれ自体で非常に便利なのではありませんが、参照の後ろに置かれたときに[`&str`][strings]のように便利になります。
そのため、私たちはそれをそのままで置いておくでしょう。

[dst]: unsized-types.html
[strings]: strings.html

あなたは`str`のさらなるドキュメントを[標準ライブラリーのドキュメントの中][str]で見付けることができます。

[str]: ../std/primitive.str.html

# タプル

タプルは固定サイズの順序付きリストです。
このようなものです。

```rust
let x = (1, "hello");
```

丸括弧とコンマがこの長さ2のタプルを形成します。
これは同じコードですが、型注釈が付いています。

```rust
let x: (i32, &str) = (1, "hello");
```

あなたが思っているとおり、タプルの方はタプルとちょうど同じように見えます。しかし、各位置には値ではなく型名が付いています。
注意深い読者は、タプルが異なる型の値を含んでいることにも気が付くでしょう。私たちはこのタプルに`i32`と`&str`を持ちます。
システムプログラミング言語では、文字列は他の言語よりも少し複雑です。
今のところ、`&str`を *文字列スライス* と読むだけにしましょう。そして、私たちは後でもっと学ぶでしょう。

もしそれらの持っている型と[アリティー][arity]が同じであれば、あなたはタプルを他のタプルに割り当てることができます。

[arity]: glossary.html#arity

```rust
let mut x = (1, 2); // x: (i32, i32)
let y = (2, 3); // y: (i32, i32)

x = y;
```

あなたはタプルのフィールドに *デストラクチャリングlet* を通じてアクセスすることができます。
これが例です。

```rust
let (x, y, z) = (1, 2, 3);

println!("x is {}", x);
```

[前に][let]私が`let`文の左辺は単なる束縛の割当てよりももっと強力だと言ったときのことを覚えていますか。
そこに着きました。
私たちは`let`の左辺にパターンを書くことができ、もしそれが左辺とマッチしたならば、私たちは複数の束縛を一度に割り当てることができます。
この場合、`let`が「デストラクチャー」、つまりタプルを「分解して」、要素を3つの束縛に割り当てます。

[let]: variable-bindings.html

このパターンは非常に強力で、私たちは後で繰り返しそれを見るでしょう。

あなたはコンマを付けて要素1のタプルを丸括弧の中の値と混同しないようにすることができます。

```rust
(0,); // single-element tuple
(0); // zero in parentheses
```

## タプルのインデックス

あなたはタプルのフィールドにインデックス構文でアクセスすることもできます。

```rust
let tuple = (1, 2, 3);

let x = tuple.0;
let y = tuple.1;
let z = tuple.2;

println!("x is {}", x);
```

配列のインデックスと同じように、それは0から始まります。しかし、配列のインデックスと異なり、それは`[]`ではなく`.`を使います。

あなたはタプルのさらなるドキュメントを[標準ライブラリーのドキュメントの中][tuple]で見付けることができます。

[tuple]: ../std/primitive.tuple.html

# 関数

関数も型を持ちます！　
それらはこのように見えます。

```rust
fn foo(x: i32) -> i32 { x }

let x: fn(i32) -> i32 = foo;
```

この場合、`x`は`i32`を受け取り`i32`を戻す関数への「関数ポインター」です。
