% 並行性

並行性と並列性は、コンピューターサイエンスにおいて極めて重要な話題です。そして、それは今日では産業界においてもホットな話題です。
コンピューターのコアはどんどん増えていきますが、多くのプログラマーはたくさんのコアを活用するための準備ができていません。

Rustのメモリー安全性の機能は、その並行性の話題にも適合的です。
並行に動作するRustプログラムもメモリー安全でなければならず、データ競合は起こりません。
Rustの型システムは仕事に耐え、あなたはコンパイル時に並行に動作するコードについて推論するための強力な方法を得ることができます。

私たちがRustに備わっている並行性の機能について話す前に、次のことを理解しておくことが重要です。Rustはかなり低レベルなので、並行性の機能を言語レベルで提供しているのではなく、標準ライブラリーレベルで提供しています。
これは、もしあなたがRustにおける並行性の扱い方のいくつかの面を気に入らないのであれば、あなたはそうするための別の方法を実装することができるということを意味します。
[mio](https://github.com/carllerche/mio)はその原則を実行に移した実例です。

## 背景としての`Send`と`Sync`

並行性は理解の難しいものです。
Rustでは、コードの理解を助けるために、私たちは強力で静的な型システムを持っています。
例えば、Rustは並行に動作するコードの理解を助けるために、私たちに2つのトレイトを提供しています。

### `Send`

私たちが最初に話そうとしているトレイトは[`Send`](../std/marker/trait.Send.html)です。
型`T`が`Send`を実装しているとき、それはこの型のものはスレッド間で所有権を移転することができるということを示します。

これはある制約を強制するために重要です。
例えば、私たちが2つのスレッドを接続するチャネルを持っているとき、私たちはチャネルにデータを入れて、もう1つのスレッドに送ることができるようにしたいと思うでしょう。
そのために、私たちはその型に`Send`が実装されていることを確実にします。

一方で、もし私たちが[FFI][ffi]を使ったスレッドセーフでないライブラリーをラップしているのであれば、私たちは`Send`を実装したいとは思わないでしょう。そうすれば、それが現在のスレッドから離れられないように、コンパイラーが強制してくれます。

[ffi]: ffi.html

### `Sync`

2つ目のトレイトは[`Sync`](../std/marker/trait.Sync.html)というものです。
型`T`が`Sync`を実装しているとき、それはこの型のものが参照を共有することで複数のスレッドから並行して使われてもメモリーの安全性を損なわないということを示します。
これは、[内的ミュータビリティー](mutability.html)を持たない型は本来的に`Sync`であるということを含んでいます。そのような型には、単純なプリミティブ型（`u8`のような）やそれらを含む集合の型が含まれます。

スレッド間で参照を共有するために、Rustは`Arc<T>`というラッパー型を提供しています。
`Arc<T>`は`T`が`Send`、`Sync`の両方を実装している場合に限り、`Send`、`Sync`を実装します。
例えば、`Arc<RefCell<U>>`型のオブジェクトはスレッド間で転送することができません。なぜなら、[`RefCell`](choosing-your-guarantees.html#refcellt)は`Sync`を実装しておらず、従って`Arc<RefCell<U>>`も`Send`を実装しないからです。

これらの2つのトレイトによって、私たちは並行性の下でコードの所有物を強力に保証するために型システムを使うことができます。
その理由を証明する前に、まず、私たちは並行に動作するRustプログラムの作り方を学ぶ必要があります！

## スレッド

Rustの標準ライブラリーはスレッドのためのライブラリーを提供しています。これによって、あなたはRustのコードを並列実行することができます。
これは`std::thread`を使った基本的な例です。

```rust
use std::thread;

fn main() {
    thread::spawn(|| {
        println!("Hello from a thread!");
    });
}
```

`thread::spawn()`メソッドは、新しいスレッドの中で実行される[クロージャー](closures.html)を受け取ります。
そのメソッドはスレッドのハンドルを戻します。そのハンドルは子スレッドが終わって結果を戻すのを待つために使うことができます。

```rust
use std::thread;

fn main() {
    let handle = thread::spawn(|| {
        "Hello from a thread!"
    });

    println!("{}", handle.join().unwrap());
}
```

多くの言語にはスレッドを実行する能力がありますが、それは大体アンセーフです。
ミュータブルな状態を共有することによって引き起こされるエラーを回避する方法についての本が一式あります。
ここでも、Rustはその型システムによってコンパイル時のデータ競合を回避することで手助けします。
あなたが実際にはどのようにスレッド間で何かを共有するのかについて話しましょう。

## 安全な共有されているミュータブルな状態

Rustの型システムによって、私たちは嘘っぽく聞こえる概念を得ました。「安全な共有されているミュータブルな状態」です。
多くのプログラマーは、共有されているミュータブルな状態は非常に非常に悪いということに同意します。

ある人はかつてこう言いました。

> 共有されたミュータブルな状態は全ての悪の根源である。
> 多くの言語はこの問題を「ミュータブル」な部分の問題として扱おうとした。しかし、Rustはそれを「共有」された部分を解決することによって扱うのだ。

ポインターを不正に使うことを回避することを手助けする[所有権システム](ownership.html)が、最も悪い並列性のバグの1つであるデータ競合を排除するために役立つのと同様です。

例のとおり、これは多くの言語ではデータ競合を含むことになるRustのプログラムです。
これはコンパイルできません。

```ignore
use std::thread;

fn main() {
    let mut data = vec![1, 2, 3];

    for i in 0..3 {
        thread::spawn(move || {
            data[i] += 1;
        });
    }

    thread::sleep_ms(50);
}
```

これはエラーを出します。

```text
8:17 error: capture of moved value: `data`
        data[i] += 1;
        ^~~~
```

Rustはこれが安全ではないことを知っているのです！
もし私たちが各スレッドに`data`の参照を持っていて、そのスレッドが参照の所有権を受け取れば、私たちは3人の所有者を抱えることになります！

そこで、私たちは値に対する参照を1つより多く持つことができ、スレッド間で共有できるような型を必要とします。その型は`Sync`を実装しなければなりません。

私たちはRustの標準的なアトミック参照カウント型、`Arc<T>`を使います。これは、値にその所有権を複数の参照の間で共有することができるような実行時の記録保持機能を追加してラップします。

その記録保持機能はその値に対していくつの参照が存在するのかをカウントを含みます。そのため、参照カウント（reference count）がその名前の一部になっています。

アトミックの部分の意味は、`Arc<T>`に複数のスレッドから安全にアクセスできることを意味します。
こうすることで、内部カウントの変更がデータ競合を起こさない分割不可能な作業を使うことをコンパイラーが保証してくれます。

```ignore
use std::thread;
use std::sync::Arc;

fn main() {
    let mut data = Arc::new(vec![1, 2, 3]);

    for i in 0..3 {
        let data = data.clone();
        thread::spawn(move || {
            data[i] += 1;
        });
    }

    thread::sleep_ms(50);
}
```

今度は、私たちは`Arc<T>`の`clone()`を呼び出しました。これは内部カウントを増加させます。
それから、このハンドルは新しいスレッドへと移転します。

そして……、まだエラーが出ます。

```text
<anon>:11:24 error: cannot borrow immutable borrowed content as mutable
<anon>:11                    data[i] += 1;
                             ^~~~
```

`Arc<T>`はその内容についてのもう1つの所有物がスレッド間で安全に共有できることを保証していることを仮定します。それは、その内容が`Sync`であるということを仮定します。
これは私たちの値がイミュータブルであれば正しいですが、私たちはそれを変更できるようにしたいので、ボローチェッカーに対して私たちは何をしているのかを理解しているのだと説得する何かが必要です。

それは共有されている値を安全に変更できるようにする型を必要としているようなものです。例えば、いつでも同時には1つのスレッドしかその中の値を変更できないことを保証できる型です。

そのために、私たちは`Mutex<T>`型を使うことができます！

これが動作するバージョンです。

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let data = Arc::new(Mutex::new(vec![1, 2, 3]));

    for i in 0..3 {
        let data = data.clone();
        thread::spawn(move || {
            let mut data = data.lock().unwrap();
            data[i] += 1;
        });
    }

    thread::sleep_ms(50);
}
```

`i`の値はそのクロージャーに束縛され（コピーされ）、スレッド間では共有されないことに注意しましょう。

[`Mutex`](../std/sync/struct.Mutex.html)の[`lock`](../std/sync/struct.Mutex.html#method.lock)メソッドがこのシグニチャーを持っていることにも注意しましょう。

```ignore
fn lock(&self) -> LockResult<MutexGuard<T>>
```

`MutexGuard<T>`には`Send`が実装されておらず、そのガードはスレッドの境界をまたぐことができないので、ロックの取得と解放がスレッドローカルであることが保証されます。

スレッドの本体をもっと詳しく調べましょう。

```rust
# use std::sync::{Arc, Mutex};
# use std::thread;
# fn main() {
#     let data = Arc::new(Mutex::new(vec![1, 2, 3]));
#     for i in 0..3 {
#         let data = data.clone();
thread::spawn(move || {
    let mut data = data.lock().unwrap();
    data[i] += 1;
});
#     }
#     thread::sleep_ms(50);
# }
```

最初に、私たちは`lock()`を呼び出します。これはミューテックスのロックを取得します。
これは失敗するかもしれないので、`Result<T, E>`を戻します。これは単なる例なので、私たちはデータの参照を得るために`unwrap()`しています。
本当のコードでは、ここでもっと強固なエラー処理をします。
そして、私たちはロックを得たので、データを自由に変更します。

最後に、スレッドを実行している間、私たちは短いタイマーで待ちます。
しかし、これは理想的な方法ではありません。私たちはちょうどよい待ち時間を選べるかもしれませんが、それはそのプログラムを実行するときに、そのスレッドが実際に計算を終えるのに掛かる時間に依存するので、必要以上に待つことになったり待ち時間が十分でなかったりすることの方が多いでしょう。

タイマーより簡潔な代替品は、スレッドを互いに同期させるためにRustの標準ライブラリーの提供するメカニズムの1つを使うことです。
その1つについて話しましょう。チャネルです。

## チャネル

これは特定の時間だけ待つのではなく、同期にチャネルを使うバージョンの私たちの例です。

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::sync::mpsc;

fn main() {
    let data = Arc::new(Mutex::new(0));

    let (tx, rx) = mpsc::channel();

    for _ in 0..10 {
        let (data, tx) = (data.clone(), tx.clone());

        thread::spawn(move || {
            let mut data = data.lock().unwrap();
            *data += 1;

            tx.send(());
        });
    }

    for _ in 0..10 {
        rx.recv();
    }
}
```

私たちは新しいチャネルを構築するために`mpsc::channel()`メソッドを使います。
私たちは単純な`()`をチャネルに`send`し、それら10個が帰ってくるまで待ちます。

このチャネルは一般的な信号を送っているだけですが、私たちは`Send`の付いているデータであれば何でもチャネルを通じて送ることができます！

```rust
use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    for i in 0..10 {
        let tx = tx.clone();

        thread::spawn(move || {
            let answer = i * i;

            tx.send(answer);
        });
    }

    for _ in 0..10 {
        println!("{}", rx.recv().unwrap());
    }
}
```

これは10個のスレッドを生成し、それぞれに対して数値（`spawn()`したときの`i`）の平方を要求し、それから解答がチャネルを通じて`send()`されます。

## パニック

`panic!`は現在実行中のスレッドをクラッシュさせます。
あなたはRustのスレッドを簡単な隔離のメカニズムとして使うことができます。

```rust
use std::thread;

let handle = thread::spawn(move || {
    panic!("oops!");
});

let result = handle.join();

assert!(result.is_err());
```

`Thread.join()`は私たちに`Result`を戻します。それによって私たちはそのスレッドがパニックしたのかそうでないのかをチェックすることができます。