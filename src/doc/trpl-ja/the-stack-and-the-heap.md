% スタックとヒープ

システム言語として、Rustは低レベルでの操作を行います。
もしあなたが高レベルの言語出身であれば、あなたがあまり慣れていないかもしれないシステムプログラミングの側面がいくつかあります。
最も重要なことは、スタックとヒープを使って、メモリーがどのように動作するのかということです。
もしあなたがC系の言語によるスタック割当ての使い方に慣れているのであれば、この章は記憶を整理してくれるでしょう。
もし慣れていないのであれば、Rust的な視点からではありますが、このことについて一般的な概念を学ぶことができるでしょう。

# メモリー管理

これら2つの用語はメモリー管理についてのものです。
スタックとヒープは、あなたがメモリーの割当てと解放をいつ行うかを決めるための手助けとなる抽象です。

以下は高レベルでの比較です。

スタックは非常に速く、Rustにおいてはデフォルトでメモリーを割り当てる場所です。
しかし、その割当ては関数呼出しに対してローカルであり、サイズは制限されます。
一方、ヒープは遅く、あなたのプログラムで明示的に割り当てるものです。
しかし、サイズは事実上無制限であり、グローバルにアクセスすることができます。

# スタック

このRustのプログラムについて話しましょう。

```rust
fn main() {
    let x = 42;
}
```

このプログラムは1つの変数束縛`x`を持ちます。
このメモリーはどこかで割り当てなければなりません。
Rustはデフォルトで「スタック割当て」です。これは、基本的な値については「スタックに送られる」ということです。
それはつまりどういうことでしょうか。

はい、関数が呼び出されたとき、全てのローカル変数といくつかの他の情報のためにメモリーが割り当てられます。
これは「スタックフレーム」と呼ばれます。私たちはこのチュートリアルの目的から、他の情報については無視して、私たちが割り当てるのはローカル変数だと単に考えましょう。
この例では、`main()`を実行するとき、私たちは1つの32ビット整数をスタックフレームに割り当てます。
見てのとおり、これは自動的に扱われます。私たちが特別なRustのコードか何かを書く必要はありませんでした。

関数が終了するとき、スタックフレームは解放されます。
これも自動的に起こります。

この単純なプログラムではこれで全てです。
ここで理解するための鍵となることは、スタック割当ては非常に非常に高速であるということです。
私たちは全てのローカル変数について事前に知っているので、全てのメモリーを一度に確保することができます。
同様に、私たちはそれら全てを同時に破棄するので、非常に高速に解放することができます。

マイナス面は、1つの関数よりも長く必要とするときに、値を保持しておくことができないことです。
私たちは「スタック」という言葉の意味についてもまだ話していませんでした。
そのためには、もう少し複雑な例が必要です。

```rust
fn foo() {
    let y = 5;
    let z = 100;
}

fn main() {
    let x = 42;

    foo();
}
```

このプログラムは合計3つの変数を持ちます。2つは`foo()`の中で、1つは`main()`の中です。
先程の例と全く同じように、`main()`を呼び出すとき、1つの整数をそのスタックフレームに割り当てます。
しかし、`foo()`を呼び出したときに何が起こるかを見る前に、メモリーについて何が起こっているのかを視覚化する必要があります。
あなたのオペレーティングシステムはあなたのプログラムに対して、メモリーを非常に単純な形で見せます。0から、あなたのコンピューターがどれくらいの容量のRAMを搭載しているかを表現する大きな値までの巨大なアドレスのリストです。
例えば、仮にあなたが1ギガバイトのRAMを持っているとすれば、あなたのアドレスは`0`から`1,073,741,823`まで続くことになります。
この数値は2<sup>30</sup>に当たり、1ギガバイトをバイトで表現した数値です。

このメモリーは巨大な配列の一種です。アドレスは0から始まり最後の数まで続きます。
そして、次の図が1つ目のスタックフレームです。

| Address | Name | Value |
|---------|------|-------|
| 0       | x    | 42    |

私たちは`x`を値`42`とともにアドレス`0`に配置しました。

`foo()`を呼び出すときに、新しいスタックフレームを割り当てます。

| Address | Name | Value |
|---------|------|-------|
| 2       | z    | 100   |
| 1       | y    | 5     |
| 0       | x    | 42    |

`0`は1つ目のフレームに使われているので、`foo()`のスタックフレームは`1`と`2`を使います。
私たちが関数を呼び出せば呼び出すほど、アドレスは上に向かって進みます。

ここには私たちが注目すべきことがいくつかあります。
0、1、そして2は全て単に説明のためのものであり、コンピューターが実際に使う数値とは何の関係もありません。
特に、一連のアドレスは現実には、各アドレスを分けるいくつかのバイトによって分断されていて、保存される値のサイズを超えることさえあります。

`foo()`が終わると、そのフレームを解放します。

| Address | Name | Value |
|---------|------|-------|
| 0       | x    | 42    |

そして、`main()`の後には、この最後の値もなくなってしまいます。
簡単ですね！

これが「スタック」と呼ばれるのは、それが夕食の皿を積み重ねたものに似た動きをするからです。あなたが最初に置いた皿は取り上げるときには最後の皿です。
この理由から、スタックは「後入れ先出し」と呼ばれることもあります。あなたが最後にスタックに入れた値は取り出すときには最初の値になるからです。

深さ3の例に挑戦しましょう。

```rust
fn bar() {
    let i = 6;
}

fn foo() {
    let a = 5;
    let b = 100;
    let c = 1;

    bar();
}

fn main() {
    let x = 42;

    foo();
}
```

よし、まず、私たちは`main()`を呼び出します。

| Address | Name | Value |
|---------|------|-------|
| 0       | x    | 42    |

次に、`main()`は`foo()`を呼び出します。

| Address | Name | Value |
|---------|------|-------|
| 3       | c    | 1     |
| 2       | b    | 100   |
| 1       | a    | 5     |
| 0       | x    | 42    |

そして、`main()`は`foo()`を呼び出します。

| Address | Name | Value |
|---------|------|-------|
| 4       | i    | 6     |
| 3       | c    | 1     |
| 2       | b    | 100   |
| 1       | a    | 5     |
| 0       | x    | 42    |

うわっ！
スタックは高くなってしまいました。

`bar()`が終わると、そのフレームを解放し、`foo()`と`main()`だけが残ります。

| Address | Name | Value |
|---------|------|-------|
| 3       | c    | 1     |
| 2       | b    | 100   |
| 1       | a    | 5     |
| 0       | x    | 42    |

そして、`foo()`が終わり、`main()`だけが残ります。

| Address | Name | Value |
|---------|------|-------|
| 0       | x    | 42    |

そして、これでおしまいです。
コツはつかめましたか。
それは皿を積み重ねたようなものです。一番上に載せて、一番上から取るのです。

# ヒープ

さて、これは非常にうまく動きました。しかし、全てをこのように動かすことができるわけではありません。
ときどき、メモリーを異なった関数の間で渡さなければならないことや、1つの関数の実行よりも長い時間保持しなければならないことがあります。
そのために、私たちはヒープを使うことができます。

Rustでは、あなたは[`Box<T>`型][box]を使うことでメモリーをヒープに割り当てることができます。
これが例です。

```rust
fn main() {
    let x = Box::new(5);
    let y = 42;
}
```

[box]: ../std/boxed/index.html

これが`main()`を呼び出したときにメモリーで起こることです。

| Address | Name | Value  |
|---------|------|--------|
| 1       | y    | 42     |
| 0       | x    | ?????? |

私たちはスタックに2つの変数のためのスペースを割り当てます。
いつもどおり`y`は`42`ですが、`x`はどうでしょうか。
`x`は`Box<i32>`で、ボックスはヒープにメモリーを割り当てます。
ボックスの実際の値は「ヒープ」へのポインターを持つ構造体です。
私たちがこの関数の実行を始めると、`Box::new()`が呼び出され、それはヒープにメモリーを割り当て、そこに`5`を配置します。
このときのメモリーはこのように見えます。

| Address              | Name | Value                  |
|----------------------|------|------------------------|
| (2<sup>30</sup>) - 1 |      | 5                      |
| ...                  | ...  | ...                    |
| 1                    | y    | 42                     |
| 0                    | x    | → (2<sup>30</sup>) - 1 |

私たちの仮定している1GBのRAMを搭載するコンピューターのアドレスには(2<sup>30</sup>) - 1まであります。
そして、私たちのスタックは0から始まるので、メモリーを割り当てるのに一番簡単な場所はもう一方の端です。
そのため、私たちの最初の値はメモリーの最も高い場所に配置されます。
そして、`x`の指す構造体の値は、私たちがヒープに割り当てた場所を指す[生のポインター][rawpointer]を持っています。`x`の値は(2<sup>30</sup>) - 1、私たちの求めているメモリーの位置です。

[rawpointer]: raw-pointers.html

それらの文脈の中で、メモリーの割当てと解放が実際には何を意味するのかということについては、本当に話しすぎるということがありません。
詳細まで非常に深く立ち入ることはこのチュートリアルの範囲から外れますが、ここで指摘すべき重要なことは、ヒープは単に反対の端から始まるだけのスタックではないということです。
本書のこの後に例がありますが、ヒープは好きな順番で割り当てたり解放したりできますが、そのために「落とし穴」に落ちることもあります。
この図はしばらく実行したところのプログラムのメモリーレイアウトです。

| Address              | Name | Value                  |
|----------------------|------|------------------------|
| (2<sup>30</sup>) - 1 |      | 5                      |
| (2<sup>30</sup>) - 2 |      |                        |
| (2<sup>30</sup>) - 3 |      |                        |
| (2<sup>30</sup>) - 4 |      | 42                     |
| ...                  | ...  | ...                    |
| 3                    | y    | → (2<sup>30</sup>) - 4 |
| 2                    | y    | 42                     |
| 1                    | y    | 42                     |
| 0                    | x    | → (2<sup>30</sup>) - 1 |

この場合、4つの値をヒープに割り当てていますが、そのうち2つを解放しています。
(2<sup>30</sup>) - 1と(2<sup>30</sup>) - 4との間には今は使われていない空白があります。
このようなことが起こる仕組みと理由は、ヒープを管理するためにあなたが使う戦略の種類によります。
異なるプログラムでは異なる「メモリーアロケーター」、あなたのためにメモリーを管理するライブラリーを使うことができます。
Rustのプログラムはそのために[jemalloc][jemalloc]を使います。

[jemalloc]: http://www.canonware.com/jemalloc/

それは置いておいて、例に戻りましょう。
このメモリーはヒープにあるので、ボックスを割り当てた関数より長く生存することができます。
しかし、この場合、そうはできません。[^moving]
関数が終わると、私たちは`main()`のスタックフレームを解放しなければならないのです。
しかし、`Box<T>`には方法があります。それが[Drop][drop]です。
`Box`のための`Drop`の実装はそれが作成されたときに割り当てられたメモリーを解放します。
すばらしい！
そのため、`x`がなくなるとき、それはまずヒープに割り当てられたメモリーを解放します。

| Address | Name | Value  |
|---------|------|--------|
| 1       | y    | 42     |
| 0       | x    | ?????? |

[drop]: drop.html
[^moving]: 私たちは所有権を移転することでメモリーをより長く生存させることができます。これを「ボックスからの取出し」と呼ぶこともあります。
           より複雑な例は後でカバーする予定です。

そして、スタックフレームがなくなり、全てのメモリーが解放されます。

# 引数とボロー

私たちはスタックとヒープを使った基本的な例をいくつか見ましたが、関数の引数とボローについてはどうなのでしょうか。
これは小さなRustのプログラムです。

```rust
fn foo(i: &i32) {
    let z = 42;
}

fn main() {
    let x = 5;
    let y = &x;

    foo(y);
}
```

`main()`に入ると、メモリーはこのように見えます。

| Address | Name | Value  |
|---------|------|--------|
| 1       | y    | → 0    |
| 0       | x    | 5      |

`x`はプレーンな昔ながらの`5`で、`y`は`x`への参照です。
そのため、その値は`x`の生存しているメモリーの位置の値で、この場合は`0`です。

`foo()`を呼び出したとき、引数として渡された`y`はどうでしょうか。

| Address | Name | Value  |
|---------|------|--------|
| 3       | z    | 42     |
| 2       | i    | → 0    |
| 1       | y    | → 0    |
| 0       | x    | 5      |

スタックフレームはローカルの束縛のためだけのものではなく、引数のためのものでもあります。
この場合、私たちは引数`i`とローカル変数`z`の両方を持たなければなりません。
`i`は引数`y`のコピーです。
`y`の値は`0`なので、`i`も同じです。

これは変数のボローがメモリーを解放しない理由の1つです。参照の値はメモリーの位置への単なるポインターです。
もし私たちが割り当てられているメモリーを破棄すれば、物事はうまく進まなくなるでしょう。

# 複雑な例

よし、この複雑なプログラムを順を追って見てみましょう。

```rust
fn foo(x: &i32) {
    let y = 10;
    let z = &y;

    baz(z);
    bar(x, z);
}

fn bar(a: &i32, b: &i32) {
    let c = 5;
    let d = Box::new(5);
    let e = &d;

    baz(e);
}

fn baz(f: &i32) {
    let g = 100;
}

fn main() {
    let h = 3;
    let i = Box::new(20);
    let j = &h;

    foo(j);
}
```

まず、`main()`を呼び出します。

| Address              | Name | Value                  |
|----------------------|------|------------------------|
| (2<sup>30</sup>) - 1 |      | 20                     |
| ...                  | ...  | ...                    |
| 2                    | j    | → 0                    |
| 1                    | i    | → (2<sup>30</sup>) - 1 |
| 0                    | h    | 3                      |

私たちは`j`、`i`、そして`h`のためにメモリーを割り当てます。
`i`の値はヒープ上にあり、そこを指す値を持ちます。

次に、`main()`の終わりで`foo()`を呼び出します。

| Address              | Name | Value                  |
|----------------------|------|------------------------|
| (2<sup>30</sup>) - 1 |      | 20                     |
| ...                  | ...  | ...                    |
| 5                    | z    | → 4                    |
| 4                    | y    | 10                     |
| 3                    | x    | → 0                    |
| 2                    | j    | → 0                    |
| 1                    | i    | → (2<sup>30</sup>) - 1 |
| 0                    | h    | 3                      |

`x`、`y`、そして`z`のためにスペースを割り当てます。
引数`x`は`j`と同じ値です。なぜなら、それが私たちが渡した値だからです。
それはアドレス`0`を指すポインターです。なぜなら、`j`が`h`を指しているからです。

その次に、`foo()`は`z`を渡して`baz()`を呼び出します。

| Address              | Name | Value                  |
|----------------------|------|------------------------|
| (2<sup>30</sup>) - 1 |      | 20                     |
| ...                  | ...  | ...                    |
| 7                    | g    | 100                    |
| 6                    | f    | → 4                    |
| 5                    | z    | → 4                    |
| 4                    | y    | 10                     |
| 3                    | x    | → 0                    |
| 2                    | j    | → 0                    |
| 1                    | i    | → (2<sup>30</sup>) - 1 |
| 0                    | h    | 3                      |

私たちは`f`と`g`のためのメモリーを割り当てました。
`baz()`は非常に短く、それが終わると私たちはスタックフレームを破棄します。

| Address              | Name | Value                  |
|----------------------|------|------------------------|
| (2<sup>30</sup>) - 1 |      | 20                     |
| ...                  | ...  | ...                    |
| 5                    | z    | → 4                    |
| 4                    | y    | 10                     |
| 3                    | x    | → 0                    |
| 2                    | j    | → 0                    |
| 1                    | i    | → (2<sup>30</sup>) - 1 |
| 0                    | h    | 3                      |

その次に、`foo()`は`x`と`z`とともに`bar()`を呼び出します。

| Address              | Name | Value                  |
|----------------------|------|------------------------|
| (2<sup>30</sup>) - 1 |      | 20                     |
| (2<sup>30</sup>) - 2 |      | 5                      |
| ...                  | ...  | ...                    |
| 10                   | e    | → 9                    |
| 9                    | d    | → (2<sup>30</sup>) - 2 |
| 8                    | c    | 5                      |
| 7                    | b    | → 4                    |
| 6                    | a    | → 0                    |
| 5                    | z    | → 4                    |
| 4                    | y    | 10                     |
| 3                    | x    | → 0                    |
| 2                    | j    | → 0                    |
| 1                    | i    | → (2<sup>30</sup>) - 1 |
| 0                    | h    | 3                      |

最後に私たちはヒープにもう1つの値を割り当てます。そのため、私たちは(2<sup>30</sup>) - 1から1を引かなければなりません。
これは直接`1,073,741,822`と書くよりも簡単です。
いずれにせよ、私たちはいつもどおり変数を用意します。

`bar()`の終わりに、`baz()`を呼び出します。

| Address              | Name | Value                  |
|----------------------|------|------------------------|
| (2<sup>30</sup>) - 1 |      | 20                     |
| (2<sup>30</sup>) - 2 |      | 5                      |
| ...                  | ...  | ...                    |
| 12                   | g    | 100                    |
| 11                   | f    | → 9                    |
| 10                   | e    | → 9                    |
| 9                    | d    | → (2<sup>30</sup>) - 2 |
| 8                    | c    | 5                      |
| 7                    | b    | → 4                    |
| 6                    | a    | → 0                    |
| 5                    | z    | → 4                    |
| 4                    | y    | 10                     |
| 3                    | x    | → 0                    |
| 2                    | j    | → 0                    |
| 1                    | i    | → (2<sup>30</sup>) - 1 |
| 0                    | h    | 3                      |

これで、私たちは最深部に到達しました！
うわっ！
こんなに遠くまで付いて来たことに対して、おめでとうございます。

`baz()`が終わった後に、私たちは`f`と`g`を破棄します。

| Address              | Name | Value                  |
|----------------------|------|------------------------|
| (2<sup>30</sup>) - 1 |      | 20                     |
| (2<sup>30</sup>) - 2 |      | 5                      |
| ...                  | ...  | ...                    |
| 10                   | e    | → 9                    |
| 9                    | d    | → (2<sup>30</sup>) - 2 |
| 8                    | c    | 5                      |
| 7                    | b    | → 4                    |
| 6                    | a    | → 0                    |
| 5                    | z    | → 4                    |
| 4                    | y    | 10                     |
| 3                    | x    | → 0                    |
| 2                    | j    | → 0                    |
| 1                    | i    | → (2<sup>30</sup>) - 1 |
| 0                    | h    | 3                      |

その次に、私たちは`bar()`から戻ります。
この場合の`d`は`Box<T>`なので、それが指すもの、(2<sup>30</sup>) -2も解放します。

| Address              | Name | Value                  |
|----------------------|------|------------------------|
| (2<sup>30</sup>) - 1 |      | 20                     |
| ...                  | ...  | ...                    |
| 5                    | z    | → 4                    |
| 4                    | y    | 10                     |
| 3                    | x    | → 0                    |
| 2                    | j    | → 0                    |
| 1                    | i    | → (2<sup>30</sup>) - 1 |
| 0                    | h    | 3                      |

その後に、`foo()`から戻ります。

| Address              | Name | Value                  |
|----------------------|------|------------------------|
| (2<sup>30</sup>) - 1 |      | 20                     |
| ...                  | ...  | ...                    |
| 2                    | j    | → 0                    |
| 1                    | i    | → (2<sup>30</sup>) - 1 |
| 0                    | h    | 3                      |

そして、最後に、`main()`、それが残りを削除します。
`i`が`Drop`されるとき、ヒープの最後の要素も削除されます。

# 他の言語はどうしているのか

ガベージコレクターを持つほとんどの言語はヒープ割当てがデフォルトです。
これは全ての値がボックス化されているということを意味します。
そうなっている理由にはいくつかありますが、それはこのチュートリアルの範囲から外れます。
時間を100％使ってしまわないように最適化をすることもできます。
メモリーの解放をスタックと`Drop`に頼るのではなく、代わりにガベージコレクターがヒープを扱うのです。

# どちらを使うか

もしスタックが速くて管理しやすいのであれば、なぜヒープが必要なのでしょうか。
大きな理由は、スタック割当てしかないということは、保存場所を回収するにはLIFOセマンティクスしか使えないということを意味します。
ヒープ割当ては明らかにより一般的であり、任意の順番で保存場所をプールから取り出したり戻したりできますが、複雑性というコストを伴います。

一般的に、あなたはスタック割当てを選択すべきでしょう。そのため、Rustはスタック割当てをデフォルトにしています。
基礎的なレベルでは、スタックのLIFOモデルは単純です。
これは2つの大きな効果を持ちます。実行時の効率とセマンティクス的な効果です。

## 実行時の効率

スタックのためのメモリーの管理は簡単なことです。マシンが「スタックポインター」と呼ばれる単一の値を増加したり減少したりするだけです。
ヒープのためのメモリー管理は簡単ではありません。ヒープに割り当てられたメモリーは任意の時点で解放され、ヒープに割り当てられたメモリーの各ブロックのサイズは任意であり、メモリーマネージャーは一般的に、再利用できるメモリーを特定するためにかなりハードに動かなければなりません。

もしあなたがこの話題のより深い詳細に立ち入りたいのであれば、[この論文][wilson]が導入として最適です。

[wilson]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.143.4688

## セマンティクス的な効果

スタック割当ては言語としてのRustそのものに影響を与え、そして開発者のメンタルモデルにも影響を与えます。
LIFOセマンティクスは言語としてのRustが自動的なメモリー管理を扱う方法を駆動するものです。
所有者の1人しかいないヒープ割当てのボックスの解放ですら、スタックベースのLIFOセマンティクスによって駆動することができます。このことは、この章を通じて議論してきたとおりです。
非LIFOセマンティクスの柔軟性（つまり、表現性）は一般的に、どこでメモリーが解放されるべきかをコンパイラーがコンパイル時に自動的に推論できなくなることを意味します。それは潜在的に言語そのものの外側からの動的なプロトコル（`Rc<T>`と`Arc<T>`で使われるような参照カウントはこの一例です）に頼らざるを得ず、解放を駆動せざるを得ません。

究極的には、ヒープ割当ての表現力の向上には多大な実行時のサポート（例えば、ガベージコレクターの形式を採って）や多大なプログラマーの努力（Rustコンパイラーが提供していない検証を必要とする明示的なメモリー管理の呼出しの形式を採って）を必要とします。
