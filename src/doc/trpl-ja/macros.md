% マクロ

もう私たちはRustが抽象化とコードの再利用のために提供するツールの多くについて学びました。
それらのコードの再利用の単位はリッチでセマンティックな構造を持ちます。
例えば、関数は型シグネチャーを持ち、型パラメーターはトレイトの束縛を持ち、オーバーロードされる関数は特定のトレイトに属さなければなりません。

この構造はRustのコアとなる抽象化が強力なコンパイル時の正当性チェック機能を持つことを意味します。
しかし、これは柔軟性の低下というかなりの犠牲を払います。
もしあなたが繰り返されるコードのパターンを視覚的に識別するならば、あなたはそのパターンをジェネリック関数、トレイト、Rustのセマンティクス内の他の何かとして表現することの難しさ又は厄介さに気付くかもしれません。

マクロによって私たちは構文レベルの抽象化が可能になります。
マクロの実行は「展開される」構文形式の省略表現です。
この展開はコンパイルの初期、全ての静的チェックの前に起こります。
結果として、マクロはRustのコアとなる抽象化ではできないコードの再利用の多くのパターンを捉えることができます。

欠点は、マクロベースのコードは理解しにくくなることがあるということです。なぜなら、組込みのルールが適用されることが少ないからです。
普通の関数のようによい振舞いのマクロはその実装の理解なしで使うことができます。
しかし、よい振舞いのマクロを設計することは難しいことがあります！　
加えて、マクロのコードでのコンパイラーのエラーは解釈することが難しいです。なぜなら、それらは開発者の使うソースレベル形式ではなく、展開されたコードでの問題を説明するからです。

それらの欠点はマクロを少し「伝家の宝刀的機能」にします。
それはマクロが悪であるということを表しません。それらはRustの一部です。なぜなら、ときどきそれらは本当に簡潔でよく抽象化されたコードのために必要になることがあるからです。
このトレードオフをしっかり念頭に置きましょう。

# マクロの定義

あなたは`vec!`マクロを見たことがあるかもしれません。それは任意の個数の要素を持つ[ベクター][vector]の初期化に使われます。

[vector]: vectors.html

```rust
let x: Vec<u32> = vec![1, 2, 3];
# assert_eq!(x, [1, 2, 3]);
```

これを普通の関数にすることはできません。なぜなら、それは任意の個数の引数を受け取るからです。
しかし、私たちはそれを構文上の省略表現として想像することができます。

```rust
let x: Vec<u32> = {
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
};
# assert_eq!(x, [1, 2, 3]);
```

私たちはこの省略表現をマクロを使って実装することができます。[^actual]

[^actual]: libcollectionsでの`vec!`の実際の定義は、効率と再利用性の理由からここで提示したものとは異なります。

```rust
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
# fn main() {
#     assert_eq!(vec![1,2,3], [1, 2, 3]);
# }
```

うわー、何てたくさんの新しい構文でしょう！　
それを分解しましょう。

```ignore
macro_rules! vec { ... }
```

これは私たちが`vec`と名付けられたマクロを定義していることを表します。それは`fn vec`が`vec`と名付けられた関数を定義しようとすることと同様です。
散文では私たちは非公式にマクロ名にエクスクラメーションポイントを付けて書きます。例えば、`vec!`のようにです。
エクスクラメーションポイントは実行構文の一部で、マクロを普通の関数から区別するために役立ちます。

## マッチング

マクロは一連のルールを通じて定義されます。それらは場合分けのパターンマッチングです。
上で私たちは次のものを見ました。

```ignore
( $( $x:expr ),* ) => { ... };
```

これは`match`式の肢に似ていますが、マッチングはRustの構文木でコンパイル時に起きます。
最後の（ここでは唯一の）場合分けのセミコロンはオプションです。
「パターン」の`=>`の左辺は「マッチャー」として知られています。
それらは言語内に[それら独自の小さな文法][their own little grammar]を持ちます。

[their own little grammar]: ../reference.html#macros

マッチャー`$x:expr`は任意のRustの式にマッチし、その構文木を「メタ変数」`$x`に束縛するでしょう。
識別子`expr`は「フラグメント指定子」で、使用可能な全てはこの章の後の方に列挙されます。
マッチャーを`$(...),*`で囲んだものはコンマで区切られた0個以上の式にマッチするでしょう。

特別なマッチャー構文を別にして、マッチャーに現れる全てのRustのトークンはぴったりマッチしなければなりません。
例えばこうです。

```rust
macro_rules! foo {
    (x => $e:expr) => (println!("mode X: {}", $e));
    (y => $e:expr) => (println!("mode Y: {}", $e));
}

fn main() {
    foo!(y => 3);
}
```

これは次のものをプリントするでしょう。

```text
mode Y: 3
```

これだとどうでしょうか。

```rust,ignore
foo!(z => 3);
```

私たちはコンパイラーからエラーを受け取ります。

```text
error: no rules expected the token `z`
```

## 展開

マクロルールの右辺はほとんどの部分が普通のRustの構文です。
しかし、私たちはマッチャーが捉えたばらばらの構文を継ぎ合せることができます。
元の例から引用します。

```ignore
$(
    temp_vec.push($x);
)*
```

マッチした式`$x`はそれぞれマクロ展開時に1つの`push`文を生成するでしょう。
展開の繰返しはマッチャーの繰返しと「ロックステップ」で進行します（これについてはじきに詳しく説明します）。

式のマッチングのときに`$x`は既に宣言されているので、私たちは`:expr`を右辺で繰り返しません。
同様に私たちは区切りのコンマを繰返しオペレーターの一部として含めません。
代わりに、私たちは繰返しブロックの中では末尾のセミコロンを持ちます。

もう1つの詳細はこうです。`vec!`マクロは *2つの* 組の波括弧を右辺に持ちます。
それらはしばしばこのように組み合わせられます。

```ignore
macro_rules! foo {
    () => {{
        ...
    }}
}
```

外側の波括弧は`macro_rules!`構文の一部です。
実際、あなたは`()`や`[]`を代わりに使うことができます。
それらは単に全体としての右辺の範囲を定めるだけです。

内側の波括弧は展開される構文の一部です。
`vec!`マクロは式の文脈で使われるということを思い出しましょう。
`let`束縛を含めた複数の文で式を書くために、私たちはブロックを使います。
もしあなたのマクロが1つの式に展開されるならば、あなたはこの余分な波括弧の層を必要としません。

私たちはマクロが式を生成するとは決して *言い切らなかった* ということに注意しましょう。
実際、私たちがマクロを式として使うまで、これは決定されません。
注意すれば、あなたは展開がいくつかの文脈で動作するマクロを書くことができます。
例えば、データ型の省略表現は式又はパターンのどちらでも有効なことがあります。

## 繰返し

繰返しオペレーターは2つの主ななルールに従います。

1. `$(...)*`は繰返しの1つの「層」をそれの含む全ての`$name`のためにロックステップで巡回する
2. そして各`$name`は`$(...)*`と同じ個数だけマッチしたそれに属さなければならない。
   もしそれが2つ以上であれば、それは適切に複製されるであろう

この凝ったマクロは外側の繰返しレベルでの変数の複製を例示します。

```rust
macro_rules! o_O {
    (
        $(
            $x:expr; [ $( $y:expr ),* ]
        );*
    ) => {
        &[ $($( $x + $y ),*),* ]
    }
}

fn main() {
    let a: &[i32]
        = o_O!(10; [1, 2, 3];
               20; [4, 5, 6]);

    assert_eq!(a, [11, 12, 13, 24, 25, 26]);
}
```

それがマッチャー構文のほとんどです。
それらの例は`$(...)*`を使い、それは「0個以上」のマッチです。
代わりにあなたは「1つ以上」のマッチのために`$(...)+`と書くことができます。
どちらの形式もオプションとしてセパレーターを含み、それは`+`と`*`以外の任意のトークンにすることができます。

このシステムは「[Macro-by-Example](https://www.cs.indiana.edu/ftp/techreports/TR206.pdf)」（PDFリンク）に基づきます。

# 健全性

いくつかの言語はマクロを単純なテキストの置換を使って実装していて、それは様々な問題をもたらします。
例えば、このCプログラムは期待される`25`ではなく`13`をプリントします。

```text
#define FIVE_TIMES(x) 5 * x

int main() {
    printf("%d\n", FIVE_TIMES(2 + 3));
    return 0;
}
```

展開後、私たちは`5 * 2 + 3`を得ます。そして乗算は加算よりも高い優先順位を持ちます。
もしあなたがCのマクロをたくさん使っているならば、あなたはおそらくこの問題を回避するための標準的な慣習を5つ、6つくらい知っているでしょう。
Rustでは私たちはそれについて心配する必要がありません。

```rust
macro_rules! five_times {
    ($x:expr) => (5 * $x);
}

fn main() {
    assert_eq!(25, five_times!(2 + 3));
}
```

メタ変数`$x`は1つの式ノードとしてパースされ、置換後も構文木のその場所にとどまります。

マクロシステムでのもう1つの一般的な問題は「変数捕捉」です。
これはRustの式ブロックをエミュレートするために[GNU C拡張][a GNU C extension]を使ったCのマクロです。

[a GNU C extension]: https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html

```text
#define LOG(msg) ({ \
    int state = get_log_state(); \
    if (state > 0) { \
        printf("log(%d): %s\n", state, msg); \
    } \
})
```

これは恐ろしい間違いを起こす単純な利用場面です。

```text
const char *state = "reticulating splines";
LOG(state)
```

この例は次のように展開されます。

```text
const char *state = "reticulating splines";
int state = get_log_state();
if (state > 0) {
    printf("log(%d): %s\n", state, state);
}
```

`state`と名付けられた2つ目の変数は1つ目を隠蔽します。
print文はそれらの両方を参照すべきなので、これは問題です。

同等なRustのマクロは望ましい挙動を持ちます。

```rust
# fn get_log_state() -> i32 { 3 }
macro_rules! log {
    ($msg:expr) => {{
        let state: i32 = get_log_state();
        if state > 0 {
            println!("log({}): {}", state, $msg);
        }
    }};
}

fn main() {
    let state: &str = "reticulating splines";
    log!(state);
}
```

Rustは[健全なマクロシステム][hygienic macro system]を持つので、これは動きます。
各マクロ展開は別個の「構文文脈」の中で起き、各変数はそれが導入された構文文脈でタグ付けされます。
それは`main`の中の変数`state`がマクロの中の変数`state`とは異なる「色」で塗られるようなもので、そのためそれらは衝突しません。

[hygienic macro system]: https://en.wikipedia.org/wiki/Hygienic_macro

これはまた、新しい束縛を実行地点で導入するマクロの能力を制限します。
次のようなコードは動かないでしょう。

```rust,ignore
macro_rules! foo {
    () => (let x = 3);
}

fn main() {
    foo!();
    println!("{}", x);
}
```

代わりにあなたは変数名を実行文に渡す必要があり、そしてそれは正しい構文文脈でタグ付けされます。

```rust
macro_rules! foo {
    ($v:ident) => (let $v = 3);
}

fn main() {
    foo!(x);
    println!("{}", x);
}
```

これは`let`束縛とループラベルを予約しますが、[アイテム][items]は予約しません。
そのため、次のコードはコンパイルできます。

```rust
macro_rules! foo {
    () => (fn x() { });
}

fn main() {
    foo!();
    x();
}
```

[items]: ../reference.html#items

# 再帰的マクロ

マクロ展開は、展開されているものと全く同じマクロの実行を含む、別のマクロの実行を含むことができます。
それらの再帰的マクロはこの（単純化した）HTMLの省略記法が例示するような木構造の入力を処理するのに便利です。

```rust
# #![allow(unused_must_use)]
macro_rules! write_html {
    ($w:expr, ) => (());

    ($w:expr, $e:tt) => (write!($w, "{}", $e));

    ($w:expr, $tag:ident [ $($inner:tt)* ] $($rest:tt)*) => {{
        write!($w, "<{}>", stringify!($tag));
        write_html!($w, $($inner)*);
        write!($w, "</{}>", stringify!($tag));
        write_html!($w, $($rest)*);
    }};
}

fn main() {
#   // FIXME(#21826)
    use std::fmt::Write;
    let mut out = String::new();

    write_html!(&mut out,
        html[
            head[title["Macros guide"]]
            body[h1["Macros are the best!"]]
        ]);

    assert_eq!(out,
        "<html><head><title>Macros guide</title></head>\
         <body><h1>Macros are the best!</h1></body></html>");
}
```

# マクロコードのデバッグ

マクロ展開の結果を見るためには`rustc --pretty expanded`を実行します。
出力は全てのクレートを表現するので、あなたはそれを`rustc`にフィードバックすることもできます。それはときどき元のコンパイルよりもよいエラーメッセージを生成するでしょう。
複数の同じ名前の（ただし異なった構文文脈を持つ）変数が同じスコープの中に存在する場合、`--pretty expanded`の出力は異なった意味を持つことがあることに注意しましょう。
この場合、`--pretty expanded,hygiene`はあなたに構文文脈について教えるでしょう。

`rustc`はマクロのデバッグを手助けする2つの構文拡張を提供します。
今のところ、それらは不安定で機能ゲートを必要とします。

* `log_syntax!(...)`はその引数をコンパイル時に標準出力にプリントし、何も「展開」しないであろう
* `trace_macros!(true)`はマクロが展開される度にコンパイラーのメッセージを有効にするであろう。
   展開の後でそれをオフにするには`trace_macros!(false)`を使うこと

# 構文上の要求

Rustのコードが未展開のマクロを含むときでさえ、それは完全な[構文木][ast]にパースすることができます。
この特性はコードを処理するエディターや他のツールにとって非常に便利です。
それはまた、Rustのマクロシステムの設計のためにいくつかの結果を持ちます。

[ast]: glossary.html#abstract-syntax-tree

1つの結果は、マクロの実行をパースするとき、マクロが次の中のどれになるのかをRustが決定しなければならないということです。

* 0個以上のアイテム
* 0個以上のメソッド
* 式
* 文
* パターン

ブロック内でのマクロの実行はいくつかのアイテム、つまり式又は文の可能性があります。
Rustはこの曖昧さを解決するために単純なルールを使います。
アイテムになるマクロの実行は次の中のどれかでなければなりません。

* 波括弧で範囲を定められている。例えば`foo! {...}`
* 又はセミコロンで終わっている。例えば`fpp!(...);`

展開前のパースのもう1つの結果は、マクロの実行は正しいRustのトークンから成り立っていなければならないということです。
その上、丸括弧、角括弧、波括弧はマクロの実行中はバランスしていなければなりません。
例えば`foo!([)`は禁じられます。
これによってRustはどこでマクロの実行が終わるのかを知ることが可能になります。

もっと正式には、マクロ実行の本文は「トークン木」のシーケンスでなければなりません。
トークン木は次の中のどれかとして再帰的に定義されます。

* マッチする`()`、`[]`、`{}`で囲まれたトークン木のシーケンス
* 又は他の1つのトークン

マッチャー内で、各メタ変数は「フラグメント指定子」を持ち、どの文法形式がそれにマッチするのかを特定します。

* `ident`：識別子。例：`x`、`foo`
* `path`：修飾名。例：`T::SpecialA`
* `expr`：式。例：`2 + 2`、`if true then { 1 } else { 2 }`、`f(42)`.
* `ty`：型。例：`i32`、`Vec<(char, String)>`、`&T`
* `pat`：パターン。例：`Some(t)`、`(17, 'a')`、`_`
* `stmt`：1つの文。例：`let x = 3`
* `block`：波括弧で範囲を定められた一連の文。例：`{ log(error, "hi"); return 12; }`
* `item`：[アイテム][item]。例：`fn foo() { }`、`struct Bar;`
* `meta`：属性内で見られるような「メタアイテム」。例：`cfg(target_os = "windows")`
* `tt`：1つのトークン木

メタ変数の後に続くトークンに関連する追加のルールがあります。

* `expr`変数は`=> , ;`の中の1つだけを後に続けてもよい
* `ty`変数と`path`変数は`=> , : = > as`の中の1つだけを後に続けてもよい
* `pat`変数は`=> , = if in`の中の1つだけを後に続けてもよい
* 他の変数は任意のトークンを後に続けてもよい

それらのルールは既存のマクロを破壊することなくRustの構文に進化への一定の柔軟性を提供します。

マクロシステムはパースの曖昧さを全く扱いません。
例えば、文法`$($t:ty)* $e:expr`は常にパースに失敗するでしょう。なぜなら、パーサーは`$t`のパースと`$e`のパースのどちらかを選ぶことを強制されるからです。
区別するためのトークンを前に置くことで実行構文を変更することは問題を解決します。
この場合、あなたは`$(T $t:ty)* E $e:exp`と書くことができます。

[item]: ../reference.html#items

# スコーピングとマクロのインポート・エクスポート

マクロはコンパイルの初期段階、名前解決の前に展開されます。
欠点の1つは、言語内の他の構成物と比べて、マクロではスコーピングが異なる動作をすることです。

マクロの定義と展開は両方ともクレートのソースに対する1つの深さ優先、辞書順の走査内で起こります。
そして、モジュールのスコープで定義されたマクロは同じモジュール内の後続の任意のコードから見えます。そのモジュールは後続の任意の子`mod`アイテムの本文を含みます。

1つの`fn`の本文内、つまりモジュールのスコープ以外のどこかで定義されたマクロはそのアイテム内からだけ見えます。

もしモジュールが`macro_use`属性を持っていれば、そのマクロはその親モジュール内の子の`mod`アイテム以降からも見えます。
もし親も`macro_use`を持っていれば、そのときはマクロは祖父母内の親の`mod`アイテム以降からも見えるでしょう。そして同じように続きます。

`macro_use`属性は`extern crate`でも現れることがあります。
この文脈ではそれはどのマクロが外部クレートから読み込まれるのかを制御します。例を示します。

```rust,ignore
#[macro_use(foo, bar)]
extern crate baz;
```

もし属性が単に`#[macro_use]`として与えられるならば、全てのマクロが読み込まれます。
もし`#[macro_use]`属性がなければ、どのマクロも読み込まれません。
`#[macro_export]`属性を付けて定義されたマクロだけが読み込まれるでしょう。

クレートのマクロを出力にリンクすることなく読み込むには、同様に`#[no_link]`を使いましょう。

例を示します。

```rust
macro_rules! m1 { () => (()) }

// visible here: m1

mod foo {
    // visible here: m1

    #[macro_export]
    macro_rules! m2 { () => (()) }

    // visible here: m1, m2
}

// visible here: m1

macro_rules! m3 { () => (()) }

// visible here: m1, m3

#[macro_use]
mod bar {
    // visible here: m1, m3

    macro_rules! m4 { () => (()) }

    // visible here: m1, m3, m4
}

// visible here: m1, m3, m4
# fn main() { }
```

このライブラリーが`#[macro_use] extern crate`付きで読み込まれるとき、`m2`だけがインポートされるでしょう。

Rustのリファレンスには[マクロ関連の属性のリスト](../reference.html#macro-related-attributes)があります。

# `$crate`変数

マクロが複数のクレート内で使われるとき、さらに難しいことが起きます。
例えば、`mylib`を次のとおり定義したとします。

```rust
pub fn increment(x: u32) -> u32 {
    x + 1
}

#[macro_export]
macro_rules! inc_a {
    ($x:expr) => ( ::increment($x) )
}

#[macro_export]
macro_rules! inc_b {
    ($x:expr) => ( ::mylib::increment($x) )
}
# fn main() { }
```

`inc_a`は`mylib`内でだけ動作します。一方、`inc_b`はライブラリーの外でだけ動作します。
さらに、もしユーザーが`mylib`を他の名前でインポートすれば、`inc_b`は壊れるでしょう。

Rustは（まだ）クレートの参照のための健全なシステムを持っていませんが、それはこの問題に対する単純な回避策を提供します。
`foo`と名付けられたクレートからインポートされたマクロ内では、特別なマクロ変数`$crate`が`::foo`へと展開されるでしょう。
対照的に、マクロが定義され、それから同じクレート内で使われたとき、`$crate`は何にも展開されません。
これは私たちが次のように書くことができることを意味します。

```rust
#[macro_export]
macro_rules! inc {
    ($x:expr) => ( $crate::increment($x) )
}
# fn main() { }
```

これは私たちのライブラリーの内側と外側の両方で動作する1つのマクロを定義します。

このシステムを単純で正しく保つために、`#[macro_use] extern crate ...`は`mod`内ではなくあなたのクレートのルートにだけ現れるでしょう。
これは`$crate`が1つの識別子であることを保証します。

# 奥の方

導入的な章で再帰的マクロに言及しましたが、それは完全なストーリーを与えませんでした。
再帰マクロはもう1つの理由で便利です。つまり、各再帰実行があなたにマクロ引数のもう一度パターンマッチの機会を与えるということです。

極端な例として、決して得策とは言えませんが、[ビットワイズ循環タグシステム](https://esolangs.org/wiki/Bitwise_Cyclic_Tag)オートマトンをRustのマクロシステム内で実装することが可能です。

```rust
macro_rules! bct {
    // cmd 0:  d ... => ...
    (0, $($ps:tt),* ; $_d:tt)
        => (bct!($($ps),*, 0 ; ));
    (0, $($ps:tt),* ; $_d:tt, $($ds:tt),*)
        => (bct!($($ps),*, 0 ; $($ds),*));

    // cmd 1p:  1 ... => 1 ... p
    (1, $p:tt, $($ps:tt),* ; 1)
        => (bct!($($ps),*, 1, $p ; 1, $p));
    (1, $p:tt, $($ps:tt),* ; 1, $($ds:tt),*)
        => (bct!($($ps),*, 1, $p ; 1, $($ds),*, $p));

    // cmd 1p:  0 ... => 0 ...
    (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)
        => (bct!($($ps),*, 1, $p ; $($ds),*));

    // halt on empty data string
    ( $($ps:tt),* ; )
        => (());
}
```

練習問題：`bct!`マクロの上の定義内の重複を減らすためにマクロを使いなさい。

# 一般的なマクロ

これらはあなたがRustのコードで見るであろういくつかの一般的なマクロです。

## panic!

このマクロは現在のスレッドをパニックさせます。
あなたはそれにパニックに付けるメッセージを与えることができます。

```rust,no_run
panic!("oh no!");
```

## vec!

`vec!`マクロは本書を通じて使われるので、あなたはおそらくそれを既に見ているでしょう。
それは`Vec<T>`を容易に作ります。

```rust
let v = vec![1, 2, 3, 4, 5];
```

それによってあなたはベクターを繰り返す値とともに作ることができます。
例えば、100個の0であれば、次のようになります。

```rust
let v = vec![0; 100];
```

## assert!とassert_eq!

これら2つのマクロはテストで使われます。
`assert!`はブーリアンを受け取ります。
`assert_eq!`は2つの値を受け取り、それらの相等性をチェックします。
`true`は成功し、`false`は`panic!`します。
例えば、このようになります。

```rust,no_run
// A-ok!

assert!(true);
assert_eq!(5, 3 + 2);

// nope :(

assert!(5 < 3);
assert_eq!(5, 3);
```

## try!

`try!`はエラー処理に使われます。
それは`Result<T, E>`を戻す可能性のある何かを受け取り、それが`Ok<T>`であれば`T`を与え、それが`Err(E)`であれば、それとともに`return`します。
例えば、このようになります。

```rust,no_run
use std::fs::File;

fn foo() -> std::io::Result<()> {
    let f = try!(File::create("foo.txt"));

    Ok(())
}
```

これは次のようにするよりもきれいです。

```rust,no_run
use std::fs::File;

fn foo() -> std::io::Result<()> {
    let f = File::create("foo.txt");

    let f = match f {
        Ok(t) => t,
        Err(e) => return Err(e),
    };

    Ok(())
}
```

## unreachable!

このマクロはあなたがあるコードが絶対に実行されるべきではないと考えるときに使われます。

```rust
if false {
    unreachable!();
}
```

ときどき、あなたが決して実行されないであろうことを知っている異なった肢をコンパイラーがあなたに持たせることがあります。
そのような場合、あなたが間違って行き着いたときにそれが`panic!`を起こすように、このマクロを使いましょう。

```rust
let x: Option<i32> = None;

match x {
    Some(_) => unreachable!(),
    None => println!("I know x is None!"),
}
```

## unimplemented!

`unimplemented!`マクロはあなたがあなたの関数に型チェックを受けさせようとするときで、関数本文を書き上げることについて心配したくないときに使うことができます。
この状況の一例は、複数の要求されるメソッドを持つトレイトの実装に、あなたが一度に取り組みたい場合です。
あなたがそれらを書く準備ができるまで、それらを`unimplemented!`として定義しましょう。

# 手続マクロ

もしRustのマクロシステムがあなたの必要とすることをできないのであれば、あなたは代わりに[コンパイラープラグイン](compiler-plugins.html)を書きたいと思うかもしれません。
`macro_rules!`マクロと比較して、これはかなり大きな仕事で、インターフェイスの安定性は下がり、バグはを追い詰めにくくなる可能性があります。
引き換えにあなたはコンパイラー内で任意のRustのコードを実行する柔軟性を得ます。
構文拡張プラグインはこの理由からときどき「手続マクロ」と呼ばれることがあります。
